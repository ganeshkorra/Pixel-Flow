<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel flow</title>
    <style>
        html, body { height: 100%; margin: 0; font-family: Arial, sans-serif; }
        #canvas-container { width: 100%; height: 100vh; display: block; position: relative; }
        #controls { position: absolute; left: 50%; transform: translateX(-50%); bottom: 20px; display: flex; gap: 10px; }
        .color-btn { width: 40px; height: 40px; border-radius: 6px; border: 2px solid rgba(0,0,0,0.2); cursor: pointer; }
        .color-btn:focus { outline: 2px solid #fff; }
        #hint { position: absolute; left: 10px; top: 10px; background: rgba(0,0,0,0.4); color: #fff; padding: 6px 10px; border-radius: 6px; font-size: 13px; }
        
        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            #hint { font-size: 11px; padding: 5px 8px; left: 8px; top: 8px; }
            .color-btn { width: 35px; height: 35px; }
            #controls { bottom: 15px; gap: 8px; }
        }
        
        @media (max-width: 480px) {
            #hint { font-size: 10px; padding: 4px 6px; left: 5px; top: 5px; }
            .color-btn { width: 30px; height: 30px; }
            #controls { bottom: 12px; gap: 6px; }
        }
        
        /* Landscape orientation adjustments */
        @media (max-height: 500px) and (orientation: landscape) {
            #hint { font-size: 10px; padding: 4px 6px; }
            .color-btn { width: 28px; height: 28px; }
            #controls { bottom: 10px; gap: 5px; }
        }
        
        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .color-btn { width: 45px; height: 45px; }
            #hint { padding: 8px 12px; }
        }
        
        /* Prevent text selection on long touches */
        * { user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; }
        canvas { display: block; }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.153.0/build/three.module.js"
        }
    }
    </script>
</head>
<body>
    <div id="canvas-container">
        <div id="hint">Click a pig to move</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'https://unpkg.com/three@0.153.0/examples/jsm/loaders/GLTFLoader.js';
        import { FBXLoader } from 'https://unpkg.com/three@0.153.0/examples/jsm/loaders/FBXLoader.js';
        import { OrbitControls } from 'https://unpkg.com/three@0.153.0/examples/jsm/controls/OrbitControls.js';

        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);

        // Suppress FBXLoader warnings
        const originalWarn = console.warn;
        console.warn = function(...args) {
            const message = args[0]?.toString() || '';
            // Suppress FBXLoader-specific warnings about unknown materials and polygon types
            if (message.includes('THREE.FBXLoader: unknown material type') || 
                message.includes('Polygons with more than four sides')) {
                return;
            }
            originalWarn.apply(console, args);
        };

        const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
        // Fixed camera matching reference composition
        camera.position.set(0, 20, 15);
        camera.lookAt(0, 0.5, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        // Lock view: disable zoom, pan and rotate so scene matches reference
        controls.enableZoom = false;
        controls.enablePan = false;
        controls.enableRotate = false;

        const hemi = new THREE.HemisphereLight(0xffffee, 0x444444, 0.6);
        scene.add(hemi);

        const dir = new THREE.DirectionalLight(0xffffff, 1.0);
        dir.position.set(5, 10, 7.5);
        dir.castShadow = true;
        dir.shadow.camera.top = 10;
        dir.shadow.camera.bottom = -10;
        dir.shadow.camera.left = -10;
        dir.shadow.camera.right = 10;
        scene.add(dir);

        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(20, 20),
            new THREE.MeshStandardMaterial({ color: 0xeeeeee })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        const loader = new GLTFLoader();
        const colors = ['#ffb6c1','#ff4d4d','#4da6ff','#66cc66','#ffd24d','#b266ff'];
        const colorNames = ['Pink', 'Red', 'Blue', 'Green', 'Yellow', 'Purple'];
        const GRID = 3;
        const pigs = [];
        const occupancy = Array.from({length: GRID}, () => Array(GRID).fill(null));
        let tiles = [];
        let tileOccupancy = [];
        let spacingGlobal = 1.2;
        const pickable = [];
        const activeAnims = [];
        const cubesToSmash = [];
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        const clock = new THREE.Clock();
        let basePigModel = null;
        let globalPigScale = 1.2; // Default, will be updated by loader

function createPigLabelTexture(text) {
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    const ctx = canvas.getContext('2d');

    // Matching the game reference style: Bold white with thick black outline
    const fontSize = 150;
    ctx.font = `bold ${fontSize}px Arial Black, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // 1. Draw Thick Black Outline
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 28; 
    ctx.lineJoin = 'round';
    ctx.strokeText(text, 128, 128);

    // 2. Draw White Text Fill
    ctx.fillStyle = '#ffffff';
    ctx.fillText(text, 128, 128);

    return new THREE.CanvasTexture(canvas);
}

function createPigLabel(pig) {
    const text = pig.userData.value.toString();
    const texture = createPigLabelTexture(text);
    const spriteMaterial = new THREE.SpriteMaterial({ 
        map: texture, 
        transparent: true,
        depthTest: false
    });
    const sprite = new THREE.Sprite(spriteMaterial);
    sprite.scale.set(4, 4, 1);
    return sprite;
}

function updatePigLabel(pig) {
    const text = pig.userData.value.toString();
    const texture = createPigLabelTexture(text);
    const label = pig.children.find(child => child.isSprite);
    if (label) {
        label.material.map.dispose();
        label.material.map = texture;
        label.material.needsUpdate = true;
    }
}

        loader.load('pig.glb', function(gltf) {
            basePigModel = gltf.scene; // Save reference for cloning new pigs later
            const base = gltf.scene;

            // Compute scale based on original model size, so every clone uses same scale
            const baseBox = new THREE.Box3().setFromObject(base);
            const baseSize = baseBox.getSize(new THREE.Vector3());
            const maxDim = Math.max(baseSize.x, baseSize.y, baseSize.z);
            const scale = 1.2 / maxDim;
            globalPigScale = scale; // Save this value for spawning

            const grid = GRID;
            const spacing = Math.max(maxDim * scale * 1.6, 1.2);
            spacingGlobal = spacing;
            let idx = 0;

            for (let row = 0; row < grid; row++) {
                for (let col = 0; col < grid; col++) {
                    // Clone the model and ensure materials are unique per mesh
                    const clone = base.clone(true);

                    clone.traverse((node) => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                            if (Array.isArray(node.material)) {
                                node.material = node.material.map(m => m.clone());
                            } else if (node.material) {
                                node.material = node.material.clone();
                            }
                            // make meshes pickable and reference their parent clone
                            pickable.push(node);
                            node.userData.parentPig = clone;
                        }
                    });

                    clone.scale.setScalar(scale);

                    // compute bounding box for clone to place on ground
                    const box = new THREE.Box3().setFromObject(clone);
                    const center = box.getCenter(new THREE.Vector3());
                    // Move clone so it's centered around origin horizontally
                    clone.position.x += -center.x;

                    // position in grid (centered) - moved lower in Z for mobile layout
                    const x = (col - Math.floor(grid/2)) * spacing;
                    const z = (row - Math.floor(grid/2)) * spacing + 7; // Push pigs down
                    clone.position.x += x;
                    clone.position.z = z;

                    // adjust Y so feet touch ground
                    box.setFromObject(clone);
                    const yOffset = -box.min.y;
                    clone.position.y += yOffset + 0.01;

                    // rotate to 90Â° (face +X direction)
                    clone.rotation.y = Math.PI / 2;

                    // Assign values like the image (alternating 20 and 40)
                    const pigValue = (idx % 2 === 0) ? "20" : "40";
                    clone.userData.value = parseInt(pigValue);
                    const label = createPigLabel(clone);

                    // Position label on the pig's back
                    // Since we are using a Sprite, it will always face the camera
                    label.position.set(0, 4, 0);
                    label.renderOrder = 999;
                    clone.add(label);
                    // Ensure clicking the sprite label resolves back to the pig clone
                    label.userData.parentPig = clone;

                    // apply color from list (cycle through colors)
                    const color = colors[idx % colors.length];
                    clone.userData.colorName = color; // Save the color hex/name
                    clone.traverse((node) => {
                        if (node.isMesh && node.material) {
                            if (Array.isArray(node.material)) {
                                node.material.forEach(m => { if (m.color) m.color.set(color); if (m.emissive) m.emissive.set(0x000000); m.needsUpdate = true; });
                            } else {
                                const m = node.material; if (m.color) m.color.set(color); if (m.emissive) m.emissive.set(0x000000); m.needsUpdate = true;
                            }
                        }
                    });

                    // tag grid coords and register
                    clone.userData.gridRow = row;
                    clone.userData.gridCol = col;
                    clone.userData.moving = false;
                    pigs.push(clone);
                    occupancy[row][col] = clone;

                    scene.add(clone);
                    idx++;
                }
            }

            // Create 5 tiles below thread mill, above pig grid (centered horizontally)
            tiles = [];
            const tileCount = 5;
            const tileSize = Math.min(spacing * 0.9, 1.2);
            const tileHeight = 0.06;
            // z position: between thread mill and pig grid with more separation
            const zTiles = 3;
            tileOccupancy = Array(tileCount).fill(null);
            for (let i = 0; i < tileCount; i++) {
                const geom = new THREE.BoxGeometry(tileSize, tileHeight, tileSize);
                const mat = new THREE.MeshStandardMaterial({ color: 0xcccccc });
                const tile = new THREE.Mesh(geom, mat);
                tile.receiveShadow = true;
                tile.castShadow = false;
                tile.position.x = (i - Math.floor(tileCount/2)) * spacing;
                tile.position.z = zTiles;
                tile.position.y = tileHeight / 2 + 0.01;
                scene.add(tile);
                tiles.push(tile);
            }

        }, undefined, function(err){
            console.error('Error loading pig.glb', err);
        });

        // Create quilted/padded texture for thread mill
        function createQuiltedTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Base color (light gray-blue like in the image)
            ctx.fillStyle = '#a8a9b5';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw quilted diamond pattern
            const gridSize = 32;
            const lineWidth = 2;
            
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = lineWidth;
            
            for (let y = 0; y < canvas.height; y += gridSize) {
                for (let x = 0; x < canvas.width; x += gridSize) {
                    // Draw diamond pattern
                    ctx.beginPath();
                    ctx.moveTo(x + gridSize / 2, y);
                    ctx.lineTo(x + gridSize, y + gridSize / 2);
                    ctx.lineTo(x + gridSize / 2, y + gridSize);
                    ctx.lineTo(x, y + gridSize / 2);
                    ctx.closePath();
                    ctx.stroke();
                    
                    // Add shading for 3D effect
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                    ctx.beginPath();
                    ctx.moveTo(x + gridSize / 2, y);
                    ctx.lineTo(x + gridSize / 2 + 5, y + 5);
                    ctx.lineTo(x + gridSize / 2, y + gridSize / 2);
                    ctx.lineTo(x + gridSize / 2 - 5, y + 5);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    ctx.beginPath();
                    ctx.moveTo(x + gridSize / 2, y + gridSize);
                    ctx.lineTo(x + gridSize / 2 + 5, y + gridSize - 5);
                    ctx.lineTo(x + gridSize / 2, y + gridSize / 2);
                    ctx.lineTo(x + gridSize / 2 - 5, y + gridSize - 5);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.LinearFilter;
            texture.minFilter = THREE.LinearMipmapLinearFilter;
            return texture;
        }

        // Load Thread mill FBX at the top/front of the layout
        const fbxLoader = new FBXLoader();
        let threadMillModel = null; // Declare this globally with other variables at top
        fbxLoader.load('Thread mill.fbx', function(object) {
             threadMillModel = object; // Save reference
            object.scale.set(.3, .3, 0.3); // Adjust scale as needed
            object.position.z = -3; // Position at front (top of mobile view)
            object.position.y = 0;
            object.rotation.y = -Math.PI / 2; // Rotate -45 degrees
            
            const quiltedTexture = createQuiltedTexture();
            
            object.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                    
                    // Apply quilted texture to all meshes
                    if (Array.isArray(node.material)) {
                        node.material = node.material.map(m => 
                            new THREE.MeshStandardMaterial({ 
                                map: quiltedTexture,
                                color: 0xa8a9b5,
                                metalness: 0.1,
                                roughness: 0.7
                            })
                        );
                    } else if (node.material) {
                        node.material = new THREE.MeshStandardMaterial({
                            map: quiltedTexture,
                            color: 0xa8a9b5,
                            metalness: 0.1,
                            roughness: 0.7
                        });
                    }
                }
            });
            
            scene.add(object);
        }, undefined, function(err) {
            console.error('Error loading Thread mill.fbx', err);
        });

  

        // Load Cube_@@.fbx and create grouped cube arrangement
        const cubeLoader = new FBXLoader();
        cubeLoader.load('Cube_@@.fbx', (cubeModel) => {
            const cols = 20;
            const rows = 25;
            const cubeSpacing = 0.24;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const clone = cubeModel.clone(true);
                    clone.scale.setScalar(0.03);

                    // GROUPING LOGIC: Assign color based on segments of columns
                    // This creates "bands" of grouped colors
                    const colorIndex = Math.floor(c / 3) % colors.length;
                    const color = colors[colorIndex];
                    
                    clone.position.set(
                        (c - cols / 2) * cubeSpacing, 
                        0.5, 
                        (r - rows / 2) * cubeSpacing - 2.5
                    );

                    // Store position index to calculate "blocked" status
                    clone.userData = {
                        colorName: color,
                        gridX: c,
                        gridZ: r,
                        blocked: true // Will be calculated below
                    };

                    clone.traverse(n => {
                        if (n.isMesh) {
                            n.castShadow = true;
                            n.receiveShadow = true;
                            if (Array.isArray(n.material)) {
                                n.material = n.material.map(m => m.clone());
                                n.material.forEach(m => {
                                    if (m.color) m.color.set(color);
                                    m.needsUpdate = true;
                                });
                            } else if (n.material) {
                                n.material = n.material.clone();
                                if (n.material.color) n.material.color.set(color);
                                n.material.needsUpdate = true;
                            }
                        }
                    });

                    scene.add(clone);
                    cubesToSmash.push(clone);
                }
            }
            updateObstacleStatus(); // Determine who is on the outside
        }, undefined, function(err) {
            console.error('Error loading Cube_@@.fbx', err);
        });

        // Animation helper: add an animation object with update(dt)
        function addAnim(anim) { activeAnims.push(anim); }

        function tweenPosition(obj, from, to, duration) {
            return new Promise(resolve => {
                const anim = {
                    elapsed: 0,
                    duration,
                    update(dt) {
                        this.elapsed += dt;
                        const t = Math.min(this.elapsed / this.duration, 1);
                        obj.position.lerpVectors(from, to, t);
                        if (t >= 1) { return true; }
                        return false;
                    },
                    finish: resolve
                };
                addAnim(anim);   
            });
        }

        function runCircle(obj, center, duration, rotations = 2, radius = 0.25) {
            return new Promise(resolve => {
                const anim = {
                    elapsed: 0,
                    duration,
                    update(dt) {
                        this.elapsed += dt;
                        const t = Math.min(this.elapsed / this.duration, 1);
                        const angle = t * rotations * Math.PI * 2;
                        obj.position.x = center.x + Math.cos(angle) * radius;
                        obj.position.z = center.z + Math.sin(angle) * radius;
                        obj.rotation.y += dt * 6.0; // spin while running
                        if (t >= 1) { return true; }
                        return false;
                    },
                    finish: resolve
                };
                addAnim(anim);
            });
        }

        function processAnims(dt) {
            for (let i = activeAnims.length - 1; i >= 0; --i) {
                const a = activeAnims[i];
                const done = a.update(dt);
                if (done) {
                    if (a.finish) a.finish();
                    activeAnims.splice(i, 1);
                }
            }
        }

        function updateObstacleStatus() {
            cubesToSmash.forEach(target => {
                const x = target.userData.gridX;
                const z = target.userData.gridZ;

                // Check 4 neighbors
                const hasN = cubesToSmash.some(o => o.userData.gridX === x && o.userData.gridZ === z - 1);
                const hasS = cubesToSmash.some(o => o.userData.gridX === x && o.userData.gridZ === z + 1);
                const hasE = cubesToSmash.some(o => o.userData.gridX === x + 1 && o.userData.gridZ === z);
                const hasW = cubesToSmash.some(o => o.userData.gridX === x - 1 && o.userData.gridZ === z);

                // If surrounded on all 4 sides, it is an "inside" cube and blocked
                target.userData.blocked = (hasN && hasS && hasE && hasW);
            });
        }

        function getMouthPosition(pig) {
            const mouthOffset = new THREE.Vector3(0, 0.4, 0.6); // Front of pig
            mouthOffset.applyQuaternion(pig.quaternion); // Rotate offset to match pig direction
            return pig.position.clone().add(mouthOffset);
        }

        // Shake animation for blocked pigs
        function shakePig(pig) {
            const originalX = pig.position.x;
            const shakeAmount = 0.1;
            const shakeDuration = 200;
            
            addAnim({
                elapsed: 0,
                duration: shakeDuration,
                update(dt) {
                    this.elapsed += dt;
                    const t = this.elapsed / this.duration;
                    const shakes = 4;
                    const shakePhase = Math.sin(t * shakes * Math.PI * 2);
                    pig.position.x = originalX + shakePhase * shakeAmount;
                    if (t >= 1) {
                        pig.position.x = originalX;
                        return true;
                    }
                    return false;
                }
            });
        }

    // 1. Muzzle Flash Effect (At the Pig)
function createMuzzleFlash(pos) {
    const flashGeom = new THREE.SphereGeometry(0.3, 8, 8);
    const flashMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
    const flash = new THREE.Mesh(flashGeom, flashMat);
    flash.position.copy(pos);
    scene.add(flash);

    addAnim({
        elapsed: 0, duration: 100,
        update(dt) {
            this.elapsed += dt;
            const t = this.elapsed / this.duration;
            flash.scale.setScalar(1 + t * 2);
            flash.material.opacity = 1 - t;
            if (t >= 1) { scene.remove(flash); return true; }
            return false;
        }
    });
}

// 2. Impact Shard Effect (At the Cube)
function createImpactEffect(pos, color) {
    for (let i = 0; i < 4; i++) {
        const shard = new THREE.Mesh(
            new THREE.SphereGeometry(0.08, 4, 4),
            new THREE.MeshBasicMaterial({ color: color })
        );
        shard.position.copy(pos);
        const velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.1,
            Math.random() * 0.1,
            (Math.random() - 0.5) * 0.1
        );
        scene.add(shard);

        addAnim({
            elapsed: 0, duration: 300,
            update(dt) {
                this.elapsed += dt;
                const t = this.elapsed / this.duration;
                shard.position.add(velocity);
                shard.scale.setScalar(1 - t);
                if (t >= 1) { scene.remove(shard); return true; }
                return false;
            }
        });
    }
}

// 3. The Sphere Bullet
function createBullet(pig, to, color) {
    const from = getMouthPosition(pig);
    const geom = new THREE.SphereGeometry(0.12, 16, 16);
    const mat = new THREE.MeshStandardMaterial({ 
        color: 0xffffff, 
        emissive: color, 
        emissiveIntensity: 5 
    });
    const bullet = new THREE.Mesh(geom, mat);
    bullet.position.copy(from);
    scene.add(bullet);

    addAnim({
        elapsed: 0, duration: 150,
        update(dt) {
            this.elapsed += dt;
            const t = Math.min(this.elapsed / this.duration, 1);
            bullet.position.lerpVectors(from, to, t);
            if (t >= 1) { 
                createImpactEffect(to, color); // Impact particles
                scene.remove(bullet); 
                return true; 
            }
            return false;
        }
    });
}

// 4. Refined Combat Loop (The "Siege")
async function shootAtCubes(pig) {
    const myColor = pig.userData.colorName;

    while (pig.userData.moving && pig.userData.value > 0) {
        let closest = null;
        let minDist = 5;

        cubesToSmash.forEach((cube, index) => {
            // NEW RULES: Match color AND Must not be blocked by other cubes
            if (cube.userData.colorName === myColor && !cube.userData.blocked) {
                const dist = pig.position.distanceTo(cube.position);
                if (dist < minDist) {
                    minDist = dist;
                    closest = { cube, index };
                }
            }
        });

        if (closest) {
            createMuzzleFlash(getMouthPosition(pig)); 
            createBullet(pig, closest.cube.position.clone(), myColor);
            
            scene.remove(closest.cube);
            cubesToSmash.splice(closest.index, 1);
            
            // Re-calculate who is on the outside now that one cube is gone
            updateObstacleStatus(); 
            
            pig.userData.value--;
            updatePigLabel(pig);

            if (pig.userData.value <= 0) {
                console.log("Ammo empty! Freeing tile index:", pig.userData.currentTileIndex);
                const indexToFree = pig.userData.currentTileIndex;
                if (indexToFree !== undefined && tileOccupancy[indexToFree] === pig) {
                    tileOccupancy[indexToFree] = null;
                }

                scene.remove(pig);
                pig.userData.moving = false;
                return;
            }
        }
        await new Promise(r => setTimeout(r, 180)); 
    }
}

       // --- Corrected Helper Functions ---
function moveAlongPoint(obj, target, duration) {
    return new Promise(resolve => {
        const start = obj.position.clone();
        addAnim({
            elapsed: 0, duration,
            update(dt) {
                this.elapsed += dt;
                const t = Math.min(this.elapsed / this.duration, 1);
                obj.position.lerpVectors(start, target, t);
                if (t >= 1) return true;
                return false;
            },
            finish: resolve
        });
    });
}

// Function for jumps (parabola)
function jumpToPoint(obj, target, duration) {
    return new Promise(resolve => {
        const start = obj.position.clone();
        const arcHeight = 2.0; // Higher arc for clearance
        addAnim({
            elapsed: 0, duration,
            update(dt) {
                this.elapsed += dt;
                const t = Math.min(this.elapsed / this.duration, 1);
                obj.position.lerpVectors(start, target, t);
                // Simple parabola
                obj.position.y = THREE.MathUtils.lerp(start.y, target.y, t) + Math.sin(t * Math.PI) * arcHeight;
                if (t >= 1) return true;
                return false;
            },
            finish: resolve
        });
    });
}

async function performMillTravel(pig, targetTile) {
    if (!threadMillModel) return;
    pig.userData.moving = true;

    // --- Start shooting thread immediately in parallel ---
    shootAtCubes(pig);

    // KEEPING YOUR VALUES EXACTLY AS IS
    const h = 0.85; 
    const mX = threadMillModel.position.x;
    const mZ = threadMillModel.position.z; 

    // YOUR EXISTING NODES
    const pEntryStub    = new THREE.Vector3(mX - 2, h, mZ + 4.8);
    const pFrontRight   = new THREE.Vector3(mX + 3.4, h, mZ + 4.8);
    const pBackRight    = new THREE.Vector3(mX + 3.4, h, mZ - 2.8);
    const pBackLeft     = new THREE.Vector3(mX - 3.4, h, mZ - 2.8);

    // --- ADDED PHASE 5: THE BLUE ARROW NODE ---
    // Moving from the Back-Left corner down the left rail to the tip
    const pExitTip      = new THREE.Vector3(mX - 3.4, h, mZ + 2.8); 
    
    // THE FINAL JUMP TARGET
    const pFinalTile    = new THREE.Vector3(targetTile.position.x, 0.3, targetTile.position.z);

    // --- PHASE 1: JUMP IN ---
    pig.rotation.y = Math.PI / 2; 
    await jumpToPoint(pig, pEntryStub, 700);
    if (!pig.parent) return; // Pig might be destroyed if value hits 0!

    // --- PHASE 2: TRAVEL RIGHT ---
    pig.rotation.y = Math.PI/2; 
    await moveAlongPoint(pig, pFrontRight, 600);
    if (!pig.parent) return;

    // --- PHASE 3: TRAVEL UP RIGHT SIDE ---
    pig.rotation.y = Math.PI; 
    await moveAlongPoint(pig, pBackRight, 600);
    if (!pig.parent) return;

    // --- PHASE 4: TRAVEL LEFT ACROSS TOP ---
    pig.rotation.y = -Math.PI / 2; 
    await moveAlongPoint(pig, pBackLeft, 800);
    if (!pig.parent) return;

    // --- PHASE 5: THE BLUE ARROW (MOVE DOWN LEFT RAIL) ---
    // New step: walk from the back-left corner to the exit tip
    pig.rotation.y = 0; // Turn to look down toward the arrow tip
    await moveAlongPoint(pig, pExitTip, 500);
    if (!pig.parent) return;

    // --- PHASE 6: FINAL JUMP FROM EXIT TO TILE ---
    pig.rotation.y = Math.PI / 2; 
    await jumpToPoint(pig, pFinalTile, 700);
    if (!pig.parent) return;

    pig.userData.onTile = true;
    pig.userData.moving = false;
}
   function onPointerDown(event) {
    const rect = renderer.domElement.getBoundingClientRect();
    pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(pointer, camera);

    const intersects = raycaster.intersectObjects(scene.children, true);
    if (intersects.length === 0) return;

    let obj = intersects[0].object;
    let pig = null;
    while (obj) {
        if (obj.userData && obj.userData.parentPig) {
            pig = obj.userData.parentPig;
            break;
        }
        obj = obj.parent;
    }

    // Safety check
    if (!pig || pig.userData.moving) return;

    // --- RULE A: If pig is already sitting on a tile ---
    if (pig.userData.onTile) {
        if (pig.userData.value > 0) {
            console.log("Relaunching from tile to smash more cubes!");
            const myCurrentSlot = pig.userData.currentTileIndex;
            if (myCurrentSlot !== undefined) {
                tileOccupancy[myCurrentSlot] = null;
            }
            pig.userData.onTile = false; 
        } else {
            return; // Out of ammo, can't move
        }
    } 
    // --- RULE B: If pig is in the 3x3 Grid ---
    else {
        const row = pig.userData.gridRow;
        const col = pig.userData.gridCol;

        // --- TRAFFIC CHECK ---
        let isBlocked = false;
        for (let r = row - 1; r >= 0; r--) {
            if (occupancy[r][col] !== null) {
                isBlocked = true;
                break;
            }
        }

        // --- CRITICAL FIX: If blocked, STOP EVERYTHING ---
        if (isBlocked) {
            console.log("Blocked! Cannot shift or spawn.");
            shakePig(pig);
            return; // <--- This STOPS the new pig from spawning!
        }

        // If NOT blocked, start the sequence
        occupancy[row][col] = null; // 1. Free grid spot
        shiftColumnForward(row, col); // 2. Trigger shift (Spawn is inside here)
    }

    // --- GLOBAL STEP: FIND THE FIRST AVAILABLE EMPTY SLOT ---
    let targetIndex = -1;
    for (let i = 0; i < tileOccupancy.length; i++) {
        if (tileOccupancy[i] === null) {
            targetIndex = i;
            break;
        }
    }

    if (targetIndex === -1) {
        console.error("All tiles occupied! Wait for a pig to finish.");
        return;
    }

    // Assign to new home and start travel
    tileOccupancy[targetIndex] = pig;
    pig.userData.currentTileIndex = targetIndex;
    performMillTravel(pig, tiles[targetIndex]);
}

function spawnNewPig(row, col) {
    if (!basePigModel) return;

    // 1. Create Clone from the base scene saved in the loader
    const newPig = basePigModel.clone(true);

    // 2. Set exactly the SAME scale as the grid pigs
    newPig.scale.setScalar(globalPigScale);

    // 3. Assign random values/colors
    const val = Math.random() > 0.5 ? "20" : "40";
    const color = colors[Math.floor(Math.random() * colors.length)];
    
    newPig.userData = {
        value: parseInt(val),
        gridRow: row,
        gridCol: col,
        moving: false,
        onTile: false,
        parentPig: newPig,
        colorName: color
    };

    // 4. Attach the label (Ensure scale is same as your code: 4)
    const label = createPigLabel(newPig);
    label.position.set(0, 4, 0); 
    label.renderOrder = 999;
    newPig.add(label);

    // 5. Apply the colored materials exactly like your loader does
    newPig.traverse((node) => {
        if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;
            node.material = node.material.clone();
            if (node.material.color) node.material.color.set(color);
            node.userData.parentPig = newPig; // For click detection
        }
    });

    // 6. Final Position and Rotation (face +X)
    const x = (col - Math.floor(GRID/2)) * spacingGlobal;
    const z = (row - Math.floor(GRID/2)) * spacingGlobal + 7;
    
    // Spawn 2 units behind the grid, then hop in
    newPig.position.set(x, 0.5, z + 2); 
    newPig.rotation.y = Math.PI / 2;

    scene.add(newPig);
    occupancy[row][col] = newPig;

    // 7. Hopping in Animation
    const landingPos = new THREE.Vector3(x, 0.5, z);
    jumpToPoint(newPig, landingPos, 500);
}

function shiftColumnForward(vacatedRow, col) {
    // Move existing pigs up
    for (let r = vacatedRow + 1; r < GRID; r++) {
        const trailingPig = occupancy[r][col];
        if (trailingPig) {
            const targetRow = r - 1;
            occupancy[targetRow][col] = trailingPig;
            occupancy[r][col] = null;
            trailingPig.userData.gridRow = targetRow;

            const targetZ = (targetRow - Math.floor(GRID/2)) * spacingGlobal + 7;
            const targetX = (col - Math.floor(GRID/2)) * spacingGlobal;
            jumpToPoint(trailingPig, new THREE.Vector3(targetX, 0.5, targetZ), 400);
        }
    }

    // --- NEW LOGIC: FILL THE EMPTY SPACE AT THE BACK ---
    // If we shifted the whole column, row 2 is now empty.
    setTimeout(() => {
        spawnNewPig(2, col); 
    }, 200); // Small delay for better visual "waiting list" effect
}



        renderer.domElement.addEventListener('pointerdown', onPointerDown);

        function onWindowResize() {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        window.addEventListener('resize', onWindowResize);
        window.addEventListener('orientationchange', onWindowResize);

        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta() * 1000, 40); // dt in ms, capped
            processAnims(dt);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>