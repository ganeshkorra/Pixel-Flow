<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel flow</title>
    <style>
        html, body { height: 100%; margin: 0; font-family: Arial, sans-serif; }
        #canvas-container { width: 100%; height: 100vh; display: block; position: relative; }
        #controls { position: absolute; left: 50%; transform: translateX(-50%); bottom: 20px; display: flex; gap: 10px; }
        .color-btn { width: 40px; height: 40px; border-radius: 6px; border: 2px solid rgba(0,0,0,0.2); cursor: pointer; }
        .color-btn:focus { outline: 2px solid #fff; }
        #hint { position: absolute; left: 10px; top: 10px; background: rgba(0,0,0,0.4); color: #fff; padding: 6px 10px; border-radius: 6px; font-size: 13px; }
        
        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            #hint { font-size: 11px; padding: 5px 8px; left: 8px; top: 8px; }
            .color-btn { width: 35px; height: 35px; }
            #controls { bottom: 15px; gap: 8px; }
        }
        
        @media (max-width: 480px) {
            #hint { font-size: 10px; padding: 4px 6px; left: 5px; top: 5px; }
            .color-btn { width: 30px; height: 30px; }
            #controls { bottom: 12px; gap: 6px; }
        }
        
        /* Landscape orientation adjustments */
        @media (max-height: 500px) and (orientation: landscape) {
            #hint { font-size: 10px; padding: 4px 6px; }
            .color-btn { width: 28px; height: 28px; }
            #controls { bottom: 10px; gap: 5px; }
        }
        
        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .color-btn { width: 45px; height: 45px; }
            #hint { padding: 8px 12px; }
        }
        
        /* Prevent text selection on long touches */
        * { user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; }
        canvas { display: block; }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.153.0/build/three.module.js"
        }
    }
    </script>
</head>
<body>
    <div id="canvas-container">
        <!-- <div id="hint">Click a Char to move</div> -->
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'https://unpkg.com/three@0.153.0/examples/jsm/loaders/GLTFLoader.js';
        import { FBXLoader } from 'https://unpkg.com/three@0.153.0/examples/jsm/loaders/FBXLoader.js';
        import { OrbitControls } from 'https://unpkg.com/three@0.153.0/examples/jsm/controls/OrbitControls.js';





        /* =========================================================
   GLOBAL CONFIGURATION (The Source of Truth)
   ========================================================= */
window.game_object = {
    GameElements: {
        CharModel: { name: "Character Model", data: "pig.glb" },
        MachineModel: { name: "The Mill", data: "Thread mill.fbx" },
        ObstacleModel: { name: "Cube Unit", data: "Cube_@@.fbx" },
        // Matrix for the Moon/Character Pixel Art
        CharacterPattern: [
            [4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4],
            [4,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,4],
            [0,0,0,0,0,2,2,1,1,1,2,2,0,0,0,0,0,0,0,0],
            [0,0,0,0,2,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0],
            [0,0,0,2,1,1,1,1,2,2,1,1,1,2,0,0,0,0,0,0],
            [0,0,2,1,1,1,1,2,0,0,2,1,1,1,2,0,2,2,0,0],
            [0,2,1,1,1,1,1,2,0,0,2,1,1,1,1,2,1,1,2,0],
            [0,2,1,1,3,3,1,1,2,2,1,1,1,1,1,1,2,1,2,0],
            [0,2,1,1,3,3,1,1,1,1,1,1,2,2,1,1,1,2,0,0],
            [0,2,1,1,1,1,1,1,1,1,2,2,1,1,2,1,1,2,0,0],
            [0,0,2,1,1,1,1,1,2,2,1,1,1,2,1,2,2,0,0,0],
            [0,0,0,2,1,1,1,1,1,1,1,1,2,0,2,0,0,0,0,0],
            [0,0,0,0,2,2,1,1,1,1,2,2,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,2,2,2,2,0,0,0,2,2,0,0,0,0,0],
            [4,0,0,0,0,0,0,0,0,0,0,0,2,1,1,2,0,0,0,4],
            [4,4,4,4,0,0,0,0,0,0,0,0,0,2,2,0,4,4,4,4]
        ]
    },

    GameProperties: { 
        GridSize: { count: 3 }, 
        ShootInterval: { amount: 1080 }, 
        AmmoLevels: { low: 20, high: 40 },
        SpawnHeight: 0.85
    },

    GameThemes: {
        CharColors: { 
            name: "Char Character Colors",
            data: {
                0: { name: "Sky Cyan", code: "#50e3fe" },
                1: { name: "Moon Yellow", code: "#ffdf00" }, 
                2: { name: "Outline Black", code: "#000000" }, 
                3: { name: "Cheek Orange", code: "#ff7f27" },  
                4: { name: "Border Purple", code: "#b266ff" }   
            }
        },
        CubeColors: { 
            name: "Level Obstacle Colors",
            data: {
                0: { name: "Sky Cyan", code: "#50e3fe" }, 
                1: { name: "Moon Yellow", code: "#ffdf00" }, 
                2: { name: "Outline Black", code: "#000000" }, 
                3: { name: "Cheek Orange", code: "#ff7f27" },  
                4: { name: "Border Purple", code: "#b266ff" }   
            }
        },  
        Background: { 
            name: "Scenario Background",
            data: "#FFF9F1"
        }
    },

    Cta: {
        playStoreLink: "https://play.google.com/store/apps/details?id=com.loomgames.pixelflow&hl=en_IN",
        appleStoreLink: "https://apps.apple.com/us/app/pixel-flow/id6751056652"
    }
};



        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // Accessing Background
        scene.background = new THREE.Color(window.game_object.GameThemes.Background.data);

        // Suppress FBXLoader warnings
        const originalWarn = console.warn;
        console.warn = function(...args) {
            const message = args[0]?.toString() || '';
            // Suppress FBXLoader-specific warnings about unknown materials and polygon types
            if (message.includes('THREE.FBXLoader: unknown material type') || 
                message.includes('Polygons with more than four sides')) {
                return;
            }
            originalWarn.apply(console, args);
        };

        const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
        // Fixed camera matching reference composition
        camera.position.set(0, 25, 8);
        camera.lookAt(0, 0.5, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        // Lock view: disable zoom, pan and rotate so scene matches reference
        controls.enableZoom = false;
        controls.enablePan = false;
        controls.enableRotate = false;

        const hemi = new THREE.HemisphereLight(0xffffee, 0x444444, 0.6);
        scene.add(hemi);

        const dir = new THREE.DirectionalLight(0xffffff, 1.0);
        dir.position.set(5, 10, 7.5);
        dir.castShadow = true;
        dir.shadow.camera.top = 10;
        dir.shadow.camera.bottom = -10;
        dir.shadow.camera.left = -10;
        dir.shadow.camera.right = 10;
        scene.add(dir);

        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(40, 40),
            new THREE.MeshStandardMaterial({ color: 0x454966 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        const loader = new GLTFLoader();
        
        // CharColors and CubeColors color mapping
        const CharColorsData = window.game_object.GameThemes.CharColors.data;
        const cubeColorsData = window.game_object.GameThemes.CubeColors.data;
        
        // Create color array for Char spawning (indices 0-4)
        const colors = Object.keys(CharColorsData).map(k => CharColorsData[k].code);

        // Simplified Moon and Star Pattern (16 rows x 20 columns)
        // Use '0' for BG, '1' for Moon/Star, '2' for outline, '3' for cheek, '4' for border
        const moonPattern = window.game_object.GameElements.CharacterPattern;

        // Calculate color frequencies in moonPattern for weighted spawning
        const colorFrequency = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0 };
        moonPattern.forEach(row => {
            row.forEach(code => {
                colorFrequency[code]++;
            });
        });
        
        // Create weighted color pool for spawned Chars (matches cube distribution)
        const weightedColorPool = [];
        Object.keys(colorFrequency).forEach(code => {
            const frequency = colorFrequency[code];
            for (let i = 0; i < frequency; i++) {
                weightedColorPool.push(colors[parseInt(code)]);
            }
        });

        // ========================================================
        // AUTO-ARRANGE FUNCTION: Image to Level Parser
        // ========================================================
        async function parseImageToLevel(imgUrl, width, height) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = imgUrl;
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = width;
                    canvas.height = height;
                    
                    // Draw image scaled down to the machine size
                    ctx.drawImage(img, 0, 0, width, height);
                    const data = ctx.getImageData(0, 0, width, height).data;
                    const newPattern = [];

                    const palette = window.game_object.GameThemes.CubeColors.data;

                    for (let y = 0; y < height; y++) {
                        const row = [];
                        for (let x = 0; x < width; x++) {
                            const i = (y * width + x) * 4;
                            const r = data[i], g = data[i+1], b = data[i+2];
                            
                            // Logic: Find which of our 5 colors is closest to this pixel
                            let closestID = 0;
                            let minDist = Infinity;
                            
                            Object.keys(palette).forEach(id => {
                                const col = new THREE.Color(palette[id].code);
                                const dr = r - col.r * 255;
                                const dg = g - col.g * 255;
                                const db = b - col.b * 255;
                                const dist = dr*dr + dg*dg + db*db; // Math: distance check
                                if(dist < minDist) { minDist = dist; closestID = parseInt(id); }
                            });
                            row.push(closestID);
                        }
                        newPattern.push(row);
                    }
                    resolve(newPattern);
                };
            });
        }
        
        // Replace your old GRID variable
        const GRID = window.game_object.GameProperties.GridSize.count;
        const Chars = [];
        const occupancy = Array.from({length: GRID}, () => Array(GRID).fill(null));
        let tiles = [];
        let tileOccupancy = [];
        let spacingGlobal = 1.2;
        const pickable = [];
        const activeAnims = [];
        const cubesToSmash = [];
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        const clock = new THREE.Clock();
        let baseCharModel = null;
        let globalCharScale = 1.2; // Default, will be updated by loader

function createCharLabelTexture(text) {
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    const ctx = canvas.getContext('2d');

    // Matching the game reference style: Bold white with thick black outline
    const fontSize = 150;
    ctx.font = `bold ${fontSize}px Arial Black, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // 1. Draw Thick Black Outline
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 28; 
    ctx.lineJoin = 'round';
    ctx.strokeText(text, 128, 128);

    // 2. Draw White Text Fill
    ctx.fillStyle = '#ffffff';
    ctx.fillText(text, 128, 128);

    return new THREE.CanvasTexture(canvas);
}

function createCharLabel(Char) {
    const text = Char.userData.value.toString();
    const texture = createCharLabelTexture(text);
    const spriteMaterial = new THREE.SpriteMaterial({ 
        map: texture, 
        transparent: true,
        depthTest: false
    });
    const sprite = new THREE.Sprite(spriteMaterial);
    sprite.scale.set(4, 4, 1);
    return sprite;
}

function updateCharLabel(Char) {
    const text = Char.userData.value.toString();
    const texture = createCharLabelTexture(text);
    const label = Char.children.find(child => child.isSprite);
    if (label) {
        label.material.map.dispose();
        label.material.map = texture;
        label.material.needsUpdate = true;
    }
}

        // Char Loader
        loader.load(window.game_object.GameElements.CharModel.data, function(gltf) {
            baseCharModel = gltf.scene; // Save reference for cloning new Chars later
            const base = gltf.scene;

            // Compute scale based on original model size, so every clone uses same scale
            const baseBox = new THREE.Box3().setFromObject(base);
            const baseSize = baseBox.getSize(new THREE.Vector3());
            const maxDim = Math.max(baseSize.x, baseSize.y, baseSize.z);
            const scale = 1.2 / maxDim;
            globalCharScale = scale; // Save this value for spawning

            const grid = GRID;
            const spacing = Math.max(maxDim * scale * 1.6, 1.2);
            spacingGlobal = spacing;
            let idx = 0;

            for (let row = 0; row < grid; row++) {
                for (let col = 0; col < grid; col++) {
                    // Clone the model and ensure materials are unique per mesh
                    const clone = base.clone(true);

                    clone.traverse((node) => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                            if (Array.isArray(node.material)) {
                                node.material = node.material.map(m => m.clone());
                            } else if (node.material) {
                                node.material = node.material.clone();
                            }
                            // make meshes pickable and reference their parent clone
                            pickable.push(node);
                            node.userData.parentChar = clone;
                        }
                    });

                    clone.scale.setScalar(scale);

                    // compute bounding box for clone to place on ground
                    const box = new THREE.Box3().setFromObject(clone);
                    const center = box.getCenter(new THREE.Vector3());
                    // Move clone so it's centered around origin horizontally
                    clone.position.x += -center.x;

                    // position in grid (centered) - moved lower in Z for mobile layout
                    const x = (col - Math.floor(grid/2)) * spacing;
                    const z = (row - Math.floor(grid/2)) * spacing + 7; // Push Chars down
                    clone.position.x += x;
                    clone.position.z = z;

                    // adjust Y so feet touch ground
                    box.setFromObject(clone);
                    const yOffset = -box.min.y;
                    clone.position.y += yOffset + 0.01;

                    // rotate to 90Â° (face +X direction)
                    clone.rotation.y = Math.PI / 2;

                    // Assign values like the image (alternating low and high ammo)
                    const ammoVals = window.game_object.GameProperties.AmmoLevels;
                    const CharValue = (idx % 2 === 0) ? ammoVals.low.toString() : ammoVals.high.toString();
                    clone.userData.value = parseInt(CharValue);
                    const label = createCharLabel(clone);

                    // Position label on the Char's back
                    // Since we are using a Sprite, it will always face the camera
                    label.position.set(0, 4, 0);
                    label.renderOrder = 999;
                    clone.add(label);
                    // Ensure clicking the sprite label resolves back to the Char clone
                    label.userData.parentChar = clone;

                    // Finding the Char Ammo color during spawning
                    const gridColorCode = idx % 5;
                    const colorHex = window.game_object.GameThemes.CharColors.data[gridColorCode].code;
                    clone.userData.colorName = colorHex; // CRITICAL: shooter logic uses this string
                    clone.traverse((node) => {
                        if (node.isMesh && node.material) {
                            if (Array.isArray(node.material)) {
                                node.material.forEach(m => { if (m.color) m.color.set(colorHex); if (m.emissive) m.emissive.set(0x000000); m.needsUpdate = true; });
                            } else {
                                const m = node.material; if (m.color) m.color.set(colorHex); if (m.emissive) m.emissive.set(0x000000); m.needsUpdate = true;
                            }
                        }
                    });

                    // tag grid coords and register
                    clone.userData.gridRow = row;
                    clone.userData.gridCol = col;
                    clone.userData.moving = false;
                    Chars.push(clone);
                    occupancy[row][col] = clone;

                    scene.add(clone);
                    idx++;
                }
            }

            // Create 5 tiles below thread mill, above Char grid (centered horizontally)
            tiles = [];
            const tileCount = 5;
            const tileSize = Math.min(spacing * 0.9, 1.2);
            const tileHeight = 0.06;
            // z position: between thread mill and Char grid with more separation
            const zTiles = 3;
            tileOccupancy = Array(tileCount).fill(null);
            for (let i = 0; i < tileCount; i++) {
                const geom = new THREE.BoxGeometry(tileSize, tileHeight, tileSize);
                const mat = new THREE.MeshStandardMaterial({ color: 0x2b2d46 });
                const tile = new THREE.Mesh(geom, mat);
                tile.receiveShadow = true;
                tile.castShadow = false;
                tile.position.x = (i - Math.floor(tileCount/2)) * spacing;
                tile.position.z = zTiles;
                tile.position.y = tileHeight / 2 + 0.01;
                scene.add(tile);
                tiles.push(tile);
            }

        }, undefined, function(err){
            console.error('Error loading Char.glb', err);
        });

        // Create quilted/padded texture for thread mill
        function createQuiltedTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Base color (light gray-blue like in the image)
            ctx.fillStyle = '#a8a9b5';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw quilted diamond pattern
            const gridSize = 32;
            const lineWidth = 2;
            
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = lineWidth;
            
            for (let y = 0; y < canvas.height; y += gridSize) {
                for (let x = 0; x < canvas.width; x += gridSize) {
                    // Draw diamond pattern
                    ctx.beginPath();
                    ctx.moveTo(x + gridSize / 2, y);
                    ctx.lineTo(x + gridSize, y + gridSize / 2);
                    ctx.lineTo(x + gridSize / 2, y + gridSize);
                    ctx.lineTo(x, y + gridSize / 2);
                    ctx.closePath();
                    ctx.stroke();
                    
                    // Add shading for 3D effect
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                    ctx.beginPath();
                    ctx.moveTo(x + gridSize / 2, y);
                    ctx.lineTo(x + gridSize / 2 + 5, y + 5);
                    ctx.lineTo(x + gridSize / 2, y + gridSize / 2);
                    ctx.lineTo(x + gridSize / 2 - 5, y + 5);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    ctx.beginPath();
                    ctx.moveTo(x + gridSize / 2, y + gridSize);
                    ctx.lineTo(x + gridSize / 2 + 5, y + gridSize - 5);
                    ctx.lineTo(x + gridSize / 2, y + gridSize / 2);
                    ctx.lineTo(x + gridSize / 2 - 5, y + gridSize - 5);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.LinearFilter;
            texture.minFilter = THREE.LinearMipmapLinearFilter;
            return texture;
        }

        // Load Thread mill FBX at the top/front of the layout
        const fbxLoader = new FBXLoader();
        let threadMillModel = null; // Declare this globally with other variables at top
        // Machine Loader
        fbxLoader.load(window.game_object.GameElements.MachineModel.data, function(object) {
             threadMillModel = object; // Save reference
            object.scale.set(.3, .3, 0.3); // Adjust scale as needed
            object.position.z = -3; // Position at front (top of mobile view)
            object.position.y = 0;
            object.rotation.y = -Math.PI / 2; // Rotate -45 degrees
            
            const quiltedTexture = createQuiltedTexture();
            
            object.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                    
                    // Apply quilted texture to all meshes
                    if (Array.isArray(node.material)) {
                        node.material = node.material.map(m => 
                            new THREE.MeshStandardMaterial({ 
                                map: quiltedTexture,
                                color: 0xa8a9b5,
                                metalness: 0.1,
                                roughness: 0.7
                            })
                        );
                    } else if (node.material) {
                        node.material = new THREE.MeshStandardMaterial({
                            map: quiltedTexture,
                            color: 0xa8a9b5,
                            metalness: 0.1,
                            roughness: 0.7
                        });
                    }
                }
            });
            
            scene.add(object);
        }, undefined, function(err) {
            console.error('Error loading Thread mill.fbx', err);
        });

  

        // Load Cube_@@.fbx and create grouped cube arrangement
        const cubeLoader = new FBXLoader();
        
        // NEW AUTOMATIC LOADER
        const imgLevelUrl = "Screenshot 2026-02-18 132325.png"; // UPLOAD YOUR IMAGE HERE

        parseImageToLevel(imgLevelUrl, 25, 25).then(autoPattern => {
            cubeLoader.load(window.game_object.GameElements.ObstacleModel.data, (cubeModel) => {
                const rows = autoPattern.length;
                const cols = autoPattern[0].length;
                const cubeSpacing = 0.24;

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const colorCode = autoPattern[r][c];
                        const colorHex = window.game_object.GameThemes.CubeColors.data[colorCode].code;
                        
                        const clone = cubeModel.clone();
                        clone.scale.setScalar(0.03);
                        clone.position.set((c - cols/2) * cubeSpacing, 0.5, (r - rows/2) * cubeSpacing - 2.5);
                        
                        clone.userData = { colorName: colorHex, gridX: c, gridZ: r, blocked: true };
                        
                        // Color the cube automatically based on image pixel
                        clone.traverse(n => {
                            if (n.isMesh) {
                                n.material = n.material.clone();
                                n.material.color.set(colorHex);
                            }
                        });
                        scene.add(clone);
                        cubesToSmash.push(clone);
                    }
                }
                updateObstacleStatus();
            });
        });

        // Animation helper: add an animation object with update(dt)
        function addAnim(anim) { activeAnims.push(anim); }

        function tweenPosition(obj, from, to, duration) {
            return new Promise(resolve => {
                const anim = {
                    elapsed: 0,
                    duration,
                    update(dt) {
                        this.elapsed += dt;
                        const t = Math.min(this.elapsed / this.duration, 1);
                        obj.position.lerpVectors(from, to, t);
                        if (t >= 1) { return true; }
                        return false;
                    },
                    finish: resolve
                };
                addAnim(anim);   
            });
        }

        function runCircle(obj, center, duration, rotations = 2, radius = 0.25) {
            return new Promise(resolve => {
                const anim = {
                    elapsed: 0,
                    duration,
                    update(dt) {
                        this.elapsed += dt;
                        const t = Math.min(this.elapsed / this.duration, 1);
                        const angle = t * rotations * Math.PI * 2;
                        obj.position.x = center.x + Math.cos(angle) * radius;
                        obj.position.z = center.z + Math.sin(angle) * radius;
                        obj.rotation.y += dt * 6.0; // spin while running
                        if (t >= 1) { return true; }
                        return false;
                    },
                    finish: resolve
                };
                addAnim(anim);
            });
        }

        function processAnims(dt) {
            for (let i = activeAnims.length - 1; i >= 0; --i) {
                const a = activeAnims[i];
                const done = a.update(dt);
                if (done) {
                    if (a.finish) a.finish();
                    activeAnims.splice(i, 1);
                }
            }
        }

        function updateObstacleStatus() {
            cubesToSmash.forEach(target => {
                const x = target.userData.gridX;
                const z = target.userData.gridZ;

                // Check 4 neighbors
                const hasN = cubesToSmash.some(o => o.userData.gridX === x && o.userData.gridZ === z - 1);
                const hasS = cubesToSmash.some(o => o.userData.gridX === x && o.userData.gridZ === z + 1);
                const hasE = cubesToSmash.some(o => o.userData.gridX === x + 1 && o.userData.gridZ === z);
                const hasW = cubesToSmash.some(o => o.userData.gridX === x - 1 && o.userData.gridZ === z);

                // If surrounded on all 4 sides, it is an "inside" cube and blocked
                target.userData.blocked = (hasN && hasS && hasE && hasW);
            });
        }

// Calculates the snout based on current 3D rotation
function getMouthPosition(pig) {
    const mouthOffset = new THREE.Vector3(0, 0.45, 0.7); 
    mouthOffset.applyQuaternion(pig.quaternion); 
    return pig.position.clone().add(mouthOffset);
}

        // Shake animation for blocked Chars
        function shakeChar(Char) {
            const originalX = Char.position.x;
            const shakeAmount = 0.1;
            const shakeDuration = 200;
            
            addAnim({
                elapsed: 0,
                duration: shakeDuration,
                update(dt) {
                    this.elapsed += dt;
                    const t = this.elapsed / this.duration;
                    const shakes = 4;
                    const shakePhase = Math.sin(t * shakes * Math.PI * 2);
                    Char.position.x = originalX + shakePhase * shakeAmount;
                    if (t >= 1) {
                        Char.position.x = originalX;
                        return true;
                    }
                    return false;
                }
            });
        }

        // Recoil Effect (Squash & Stretch)
        function applyRecoil(Char) {
            const originalScale = globalCharScale;
            addAnim({
                elapsed: 0, duration: 150,
                update(dt) {
                    this.elapsed += dt;
                    const t = this.elapsed / this.duration;
                    // 0 -> 0.5 (squash) -> 1 (reset)
                    const squash = Math.sin(t * Math.PI);
                    Char.scale.z = originalScale * (1 - squash * 0.2); // Shrink length
                    Char.scale.y = originalScale * (1 + squash * 0.1); // Bulge height
                    if (t >= 1) { 
                        Char.scale.setScalar(originalScale);
                        return true; 
                    }
                    return false;
                }
            });
        }

// Visual glowing "Pop" when firing
function createMuzzleFlash(pos) {
    const flashGeom = new THREE.SphereGeometry(0.35, 12, 12);
    const flashMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
    const flash = new THREE.Mesh(flashGeom, flashMat);
    flash.position.copy(pos);
    scene.add(flash);
    addAnim({
        elapsed: 0, duration: 120,
        update(dt) {
            this.elapsed += dt; const t = this.elapsed / this.duration;
            flash.scale.setScalar(1 + t * 2); flash.material.opacity = 1 - t;
            if (t >= 1) { scene.remove(flash); return true; } return false;
        }
    });
}

// 2. Impact Shard Effect (At the Cube)
function createImpactEffect(pos, color) {
    for (let i = 0; i < 4; i++) {
        const shard = new THREE.Mesh(
            new THREE.SphereGeometry(0.08, 4, 4),
            new THREE.MeshBasicMaterial({ color: color })
        );
        shard.position.copy(pos);
        const velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.1,
            Math.random() * 0.1,
            (Math.random() - 0.5) * 0.1
        );
        scene.add(shard);

        addAnim({
            elapsed: 0, duration: 300,
            update(dt) {
                this.elapsed += dt;
                const t = this.elapsed / this.duration;
                shard.position.add(velocity);
                shard.scale.setScalar(1 - t);
                if (t >= 1) { scene.remove(shard); return true; }
                return false;
            }
        });
    }
}

// NEW HIGH-QUALITY AMMO: White Glowing Sphere with a long Trail
function createBullet(pig, to, color) {
    const from = getMouthPosition(pig);
    
    // Core of the bullet (Glowing White Ball)
    const bulletGroup = new THREE.Group();
    
    // 1. The Head
    const head = new THREE.Mesh(
        new THREE.SphereGeometry(0.2, 16, 16),
        new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 10, toneMapped: false })
    );
    
    // 2. The Tail (Stretch line)
    const tail = new THREE.Mesh(
        new THREE.CylinderGeometry(0.12, 0.02, 1.2, 12),
        new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 })
    );
    tail.rotation.x = Math.PI / 2; // Lie flat
    tail.position.z = -0.5; // Place behind the head
    
    bulletGroup.add(head);
    bulletGroup.add(tail);
    bulletGroup.position.copy(from);
    scene.add(bulletGroup);

    addAnim({
        elapsed: 0, duration: 180, // High speed flight
        update(dt) {
            this.elapsed += dt;
            const t = Math.min(this.elapsed / this.duration, 1);
            
            // Starts fast, finishes smoothly (Snappy!)
            const easedT = 1 - Math.pow(1 - t, 3);
            bulletGroup.position.lerpVectors(from, to, easedT);
            bulletGroup.lookAt(to); // Points the trail exactly behind the head

            if (t >= 1) { 
                createImpactEffect(to, color); // The colored explosion at the cube
                scene.remove(bulletGroup); 
                return true; 
            }
            return false;
        }
    });
}

// Integrated Combat Loop with Recoil & Beautiful Projectiles
async function shootAtCubes(pig) {
    const myColor = pig.userData.colorName;

    while (pig.userData.moving && pig.userData.value > 0) {
        let closest = null;
        let minDist = 7;

        cubesToSmash.forEach((cube, index) => {
            if (cube.userData.colorName === myColor && !cube.userData.blocked) {
                const dist = pig.position.distanceTo(cube.position);
                if (dist < minDist) { minDist = dist; closest = { cube, index }; }
            }
        });

        if (closest) {
            const muzzlePos = getMouthPosition(pig);
            
            // Trigger ALL effects simultaneously
            applyRecoil(pig);       // 1. Character Kickback
            createMuzzleFlash(muzzlePos); // 2. Snout light pop
            createBullet(pig, closest.cube.position.clone(), myColor); // 3. The Glow Bullet
            
            // Process damage
            scene.remove(closest.cube);
            cubesToSmash.splice(closest.index, 1);
            updateObstacleStatus(); // reveals inner cubes
            
            pig.userData.value--;
            updateCharLabel(pig);

            // Safety check for empty ammo
            if (pig.userData.value <= 0) {
                const idx = pig.userData.currentTileIndex;
                if (idx !== undefined && tileOccupancy[idx] === pig) tileOccupancy[idx] = null;
                scene.remove(pig);
                pig.userData.moving = false;
                return;
            }
        }
        await new Promise(r => setTimeout(r, 220)); 
    }
}

       // --- Corrected Helper Functions ---
function moveAlongPoint(obj, target, duration) {
    return new Promise(resolve => {
        const start = obj.position.clone();
        addAnim({
            elapsed: 0, duration,
            update(dt) {
                this.elapsed += dt;
                const t = Math.min(this.elapsed / this.duration, 1);
                obj.position.lerpVectors(start, target, t);
                if (t >= 1) return true;
                return false;
            },
            finish: resolve
        });
    });
}

// Function for jumps (parabola)
function jumpToPoint(obj, target, duration) {
    return new Promise(resolve => {
        const start = obj.position.clone();
        const arcHeight = 2.0; // Higher arc for clearance
        addAnim({
            elapsed: 0, duration,
            update(dt) {
                this.elapsed += dt;
                const t = Math.min(this.elapsed / this.duration, 1);
                obj.position.lerpVectors(start, target, t);
                // Simple parabola
                obj.position.y = THREE.MathUtils.lerp(start.y, target.y, t) + Math.sin(t * Math.PI) * arcHeight;
                if (t >= 1) return true;
                return false;
            },
            finish: resolve
        });
    });
}

async function performMillTravel(Char, targetTile) {
    if (!threadMillModel) return;
    Char.userData.moving = true;

    // --- Start shooting thread immediately in parallel ---
    shootAtCubes(Char);

    // The Path Heights
    const h = window.game_object.GameProperties.SpawnHeight; 
    const mX = threadMillModel.position.x;
    const mZ = threadMillModel.position.z; 

    // YOUR EXISTING NODES
    const pEntryStub    = new THREE.Vector3(mX - 2, h, mZ + 4);
    const pFrontRight   = new THREE.Vector3(mX + 2.8, h, mZ + 4);
    const pBackRight    = new THREE.Vector3(mX + 3.4, h, mZ - 2.8);
    const pBackLeft     = new THREE.Vector3(mX - 3.4, h, mZ - 2.8);

    // --- ADDED PHASE 5: THE BLUE ARROW NODE ---
    // Moving from the Back-Left corner down the left rail to the tip
    const pExitTip      = new THREE.Vector3(mX - 3.4, h, mZ + 2.8); 
    
    // THE FINAL JUMP TARGET
    const pFinalTile    = new THREE.Vector3(targetTile.position.x, 0.3, targetTile.position.z);

    // --- PHASE 1: JUMP IN ---
    Char.rotation.y = Math.PI / 2; 
    await jumpToPoint(Char, pEntryStub, 700);
    if (!Char.parent) return; // Char might be destroyed if value hits 0!

    // --- PHASE 2: TRAVEL RIGHT ---
    Char.rotation.y = Math.PI/2; 
    await moveAlongPoint(Char, pFrontRight, 600);
    if (!Char.parent) return;

    // --- PHASE 3: TRAVEL UP RIGHT SIDE ---
    Char.rotation.y = Math.PI; 
    await moveAlongPoint(Char, pBackRight, 600);
    if (!Char.parent) return;

    // --- PHASE 4: TRAVEL LEFT ACROSS TOP ---
    Char.rotation.y = -Math.PI / 2; 
    await moveAlongPoint(Char, pBackLeft, 800);
    if (!Char.parent) return;

    // --- PHASE 5: THE BLUE ARROW (MOVE DOWN LEFT RAIL) ---
    // New step: walk from the back-left corner to the exit tip
    Char.rotation.y = 0; // Turn to look down toward the arrow tip
    await moveAlongPoint(Char, pExitTip, 500);
    if (!Char.parent) return;

    // --- PHASE 6: FINAL JUMP FROM EXIT TO TILE ---
    Char.rotation.y = Math.PI / 2; 
    await jumpToPoint(Char, pFinalTile, 700);
    if (!Char.parent) return;

    Char.userData.onTile = true;
    Char.userData.moving = false;
}
   function onPointerDown(event) {
    const rect = renderer.domElement.getBoundingClientRect();
    pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(pointer, camera);

    const intersects = raycaster.intersectObjects(scene.children, true);
    if (intersects.length === 0) return;

    let obj = intersects[0].object;
    let Char = null;
    while (obj) {
        if (obj.userData && obj.userData.parentChar) {
            Char = obj.userData.parentChar;
            break;
        }
        obj = obj.parent;
    }

    if (!Char || Char.userData.moving) return;

    // --- CHECK CURRENT CAPACITY ---
    const nextAvailableSlot = tileOccupancy.indexOf(null);

    // --- PATH A: CHARACTER IS ON A TILE ---
    if (Char.userData.onTile) {
        if (Char.userData.value > 0) {
            // Instant Undeployment: This character clears its seat immediately
            const currentSlot = Char.userData.currentTileIndex;
            if (currentSlot !== undefined) {
                tileOccupancy[currentSlot] = null; // SLOT IS NOW FREE
            }
            Char.userData.onTile = false; 
        } else {
            return; // Finished its job
        }
    } 
    // --- PATH B: CHARACTER IS IN THE GRID ---
    else {
        // ETHIC 1: THE CAPACITY CHECK
        // If there is no space (no 'null' in tileOccupancy), grid Chars are LOCKED
        if (nextAvailableSlot === -1) {
            console.log("WAIT: The tiles are at capacity!");
            shakeChar(Char); // Feedback wiggle
            return; 
        }

        // ETHIC 2: THE TRAFFIC CHECK
        const row = Char.userData.gridRow;
        const col = Char.userData.gridCol;
        for (let r = row - 1; r >= 0; r--) {
            if (occupancy[r][col] !== null) {
                shakeChar(Char); 
                return; // Blocked by character in front
            }
        }

        // Everything clear: Depart from grid
        occupancy[row][col] = null;
        shiftColumnForward(row, col); 
    }

    // --- SHARED LAUNCH PAD ---
    // Now we find the leftmost spot again (either a truly empty one or the one just vacated)
    const tIdx = tileOccupancy.indexOf(null);
    if (tIdx !== -1) {
        tileOccupancy[tIdx] = Char;
        Char.userData.currentTileIndex = tIdx;
        performMillTravel(Char, tiles[tIdx]);
    }
}

function spawnNewChar(row, col) {
    if (!baseCharModel) return;

    // 1. Create Clone from the base scene saved in the loader
    const newChar = baseCharModel.clone(true);

    // 2. Set exactly the SAME scale as the grid Chars
    newChar.scale.setScalar(globalCharScale);

    // 3. Assign random values/colors
    const val = Math.random() > 0.5 ? 20 : 40;
    // PICK FROM THE WEIGHTED COLOR POOL (matches cube distribution)
    const color = weightedColorPool[Math.floor(Math.random() * weightedColorPool.length)];
    
    newChar.userData = {
        value: parseInt(val),
        gridRow: row,
        gridCol: col,
        moving: false,
        onTile: false,
        parentChar: newChar,
        colorName: color
    };

    // 4. Attach the label (Ensure scale is same as your code: 4)
    const label = createCharLabel(newChar);
    label.position.set(0, 4, 0); 
    label.renderOrder = 999;
    newChar.add(label);

    // 5. Apply the colored materials exactly like your loader does
    newChar.traverse((node) => {
        if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;
            node.material = node.material.clone();
            if (node.material.color) node.material.color.set(color);
            node.userData.parentChar = newChar; // For click detection
        }
    });

    // 6. Final Position and Rotation (face +X)
    const x = (col - Math.floor(GRID/2)) * spacingGlobal;
    const z = (row - Math.floor(GRID/2)) * spacingGlobal + 7;
    
    // Spawn 2 units behind the grid, then hop in
    newChar.position.set(x, 0.5, z + 2); 
    newChar.rotation.y = Math.PI / 2;

    scene.add(newChar);
    occupancy[row][col] = newChar;

    // 7. Hopping in Animation
    const landingPos = new THREE.Vector3(x, 0.5, z);
    jumpToPoint(newChar, landingPos, 500);
}

function shiftColumnForward(vacatedRow, col) {
    // Move existing Chars up
    for (let r = vacatedRow + 1; r < GRID; r++) {
        const trailingChar = occupancy[r][col];
        if (trailingChar) {
            const targetRow = r - 1;
            occupancy[targetRow][col] = trailingChar;
            occupancy[r][col] = null;
            trailingChar.userData.gridRow = targetRow;

            const targetZ = (targetRow - Math.floor(GRID/2)) * spacingGlobal + 7;
            const targetX = (col - Math.floor(GRID/2)) * spacingGlobal;
            jumpToPoint(trailingChar, new THREE.Vector3(targetX, 0.5, targetZ), 400);
        }
    }

    // --- NEW LOGIC: FILL THE EMPTY SPACE AT THE BACK ---
    // If we shifted the whole column, row 2 is now empty.
    setTimeout(() => {
        spawnNewChar(2, col); 
    }, 200); // Small delay for better visual "waiting list" effect
}



        renderer.domElement.addEventListener('pointerdown', onPointerDown);

        function onWindowResize() {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        window.addEventListener('resize', onWindowResize);
        window.addEventListener('orientationchange', onWindowResize);

        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta() * 1000, 40); // dt in ms, capped
            processAnims(dt);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>