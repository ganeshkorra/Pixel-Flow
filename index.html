<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel flow</title>
    <style>
        html, body { height: 100%; margin: 0; font-family: Arial, sans-serif; }
        #canvas-container { width: 100%; height: 100vh; display: block; position: relative; }
        #controls { position: absolute; left: 50%; transform: translateX(-50%); bottom: 20px; display: flex; gap: 10px; }
        .color-btn { width: 40px; height: 40px; border-radius: 6px; border: 2px solid rgba(0,0,0,0.2); cursor: pointer; }
        .color-btn:focus { outline: 2px solid #fff; }
        #hint { position: absolute; left: 10px; top: 10px; background: rgba(0,0,0,0.4); color: #fff; padding: 6px 10px; border-radius: 6px; font-size: 13px; }
        
        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            #hint { font-size: 11px; padding: 5px 8px; left: 8px; top: 8px; }
            .color-btn { width: 35px; height: 35px; }
            #controls { bottom: 15px; gap: 8px; }
        }
        
        @media (max-width: 480px) {
            #hint { font-size: 10px; padding: 4px 6px; left: 5px; top: 5px; }
            .color-btn { width: 30px; height: 30px; }
            #controls { bottom: 12px; gap: 6px; }
        }
        
        /* Landscape orientation adjustments */
        @media (max-height: 500px) and (orientation: landscape) {
            #hint { font-size: 10px; padding: 4px 6px; }
            .color-btn { width: 28px; height: 28px; }
            #controls { bottom: 10px; gap: 5px; }
        }
        
        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .color-btn { width: 45px; height: 45px; }
            #hint { padding: 8px 12px; }
        }
        
        /* Prevent text selection on long touches */
        * { user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; }
        canvas { display: block; }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.153.0/build/three.module.js"
        }
    }
    </script>
</head>
<body>
    <div id="canvas-container">
        <!-- <div id="hint">Click a Char to move</div> -->
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'https://unpkg.com/three@0.153.0/examples/jsm/loaders/GLTFLoader.js';
        import { FBXLoader } from 'https://unpkg.com/three@0.153.0/examples/jsm/loaders/FBXLoader.js';
        import { OrbitControls } from 'https://unpkg.com/three@0.153.0/examples/jsm/controls/OrbitControls.js';





        let activeLevelColors = []; // Will store only colors used in the current image
        /* =========================================================
   GLOBAL CONFIGURATION (The Source of Truth)
   ========================================================= */
window.game_object = {
    GameElements: {
    CharModel: { name: "Character Model", data: "pig.glb" },
    ObstacleModel: { name: "Cube Unit", data: "Cube_@@.fbx" },
        // Matrix for the Moon/Character Pixel Art
        CharacterPattern: [
            [4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4],
            [4,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,4],
            [0,0,0,0,0,2,2,1,1,1,2,2,0,0,0,0,0,0,0,0],
            [0,0,0,0,2,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0],
            [0,0,0,2,1,1,1,1,2,2,1,1,1,2,0,0,0,0,0,0],
            [0,0,2,1,1,1,1,2,0,0,2,1,1,1,2,0,2,2,0,0],
            [0,2,1,1,1,1,1,2,0,0,2,1,1,1,1,2,1,1,2,0],
            [0,2,1,1,3,3,1,1,2,2,1,1,1,1,1,1,2,1,2,0],
            [0,2,1,1,3,3,1,1,1,1,1,1,2,2,1,1,1,2,0,0],
            [0,2,1,1,1,1,1,1,1,1,2,2,1,1,2,1,1,2,0,0],
            [0,0,2,1,1,1,1,1,2,2,1,1,1,2,1,2,2,0,0,0],
            [0,0,0,2,1,1,1,1,1,1,1,1,2,0,2,0,0,0,0,0],
            [0,0,0,0,2,2,1,1,1,1,2,2,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,2,2,2,2,0,0,0,2,2,0,0,0,0,0],
            [4,0,0,0,0,0,0,0,0,0,0,0,2,1,1,2,0,0,0,4],
            [4,4,4,4,0,0,0,0,0,0,0,0,0,2,2,0,4,4,4,4]
        ]
    },

    GameProperties: { 
        GridSize: { count: 3}, 
        ShootInterval: { amount: 0 }, 
        AmmoLevels: { low: 0, high: 0 },
        SpawnHeight: 0.85,
        CubeSize: { size: 0.03 },
        LevelSize: { rows: 20, cols: 20 }
    },

    GameThemes: {
        CharColors: { 
            name: "Char Character Colors",
            data: {
                0: { name: "Sky Cyan", code: "#50e3fe" },
                1: { name: "Moon Yellow", code: "#ffdf00" }, 
                2: { name: "Outline Black", code: "#000000" }, 
                3: { name: "Cheek Orange", code: "#ff7f27" },  
                4: { name: "Border Purple", code: "#b266ff" }   
            }
        },
        CubeColors: { 
            name: "Level Obstacle Colors",
            data: {
                0: { name: "Sky Cyan", code: "#50e3fe" }, 
                1: { name: "Moon Yellow", code: "#ffdf00" }, 
                2: { name: "Outline Black", code: "#000000" }, 
                3: { name: "Cheek Orange", code: "#ff7f27" },  
                4: { name: "Border Purple", code: "#b266ff" }   
            }
        },  
        Background: { 
            name: "Scenario Background",
            data: "#"
        }
    },
        

    Cta: {
        playStoreLink: "https://play.google.com/store/apps/details?id=com.loomgames.pixelflow&hl=en_IN",
        appleStoreLink: "https://apps.apple.com/us/app/pixel-flow/id6751056652"
    }
};



        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // Accessing Background
        scene.background = new THREE.Color(window.game_object.GameThemes.Background.data);

        // Suppress FBXLoader warnings
        const originalWarn = console.warn;
        console.warn = function(...args) {
            const message = args[0]?.toString() || '';
            // Suppress FBXLoader-specific warnings about unknown materials and polygon types
            if (message.includes('THREE.FBXLoader: unknown material type') || 
                message.includes('Polygons with more than four sides')) {
                return;
            }
            originalWarn.apply(console, args);
        };

        const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
        // Fixed camera matching reference composition
        camera.position.set(0, 19, 10);
        camera.lookAt(0, 0.5, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        // Lock view: disable zoom, pan and rotate so scene matches reference
        controls.enableZoom = false;
        controls.enablePan = false;
        controls.enableRotate = false;

        const hemi = new THREE.HemisphereLight(0xffffee, 0x444444, 0.6);
        scene.add(hemi);

        const dir = new THREE.DirectionalLight(0xffffff, 1.0);
        dir.position.set(5, 10, 7.5);
        dir.castShadow = true;
        dir.shadow.camera.top = 10;
        dir.shadow.camera.bottom = -10;
        dir.shadow.camera.left = -10;
        dir.shadow.camera.right = 10;
        scene.add(dir);

        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(40, 40),
            new THREE.MeshStandardMaterial({ color: 0x454966 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        const loader = new GLTFLoader();
        
        // CharColors and CubeColors color mapping
        const CharColorsData = window.game_object.GameThemes.CharColors.data;
        const cubeColorsData = window.game_object.GameThemes.CubeColors.data;
        
        // Create color array for Char spawning (indices 0-4)
        const colors = Object.keys(CharColorsData).map(k => CharColorsData[k].code);

        // Simplified Moon and Star Pattern (16 rows x 20 columns)
        // Use '0' for BG, '1' for Moon/Star, '2' for outline, '3' for cheek, '4' for border
        const moonPattern = window.game_object.GameElements.CharacterPattern;

        // Calculate color frequencies in moonPattern for weighted spawning
        const colorFrequency = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0 };
        moonPattern.forEach(row => {
            row.forEach(code => {
                colorFrequency[code]++;
            });
        });
        
        // Create weighted color pool for spawned Chars (matches cube distribution)
        const weightedColorPool = [];
        Object.keys(colorFrequency).forEach(code => {
            const frequency = colorFrequency[code];
            for (let i = 0; i < frequency; i++) {
                weightedColorPool.push(colors[parseInt(code)]);
            }
        });

        // ========================================================
        // AUTO-ARRANGE FUNCTION: Image to Level Parser
        // ========================================================
        async function parseImageToLevel(imgUrl, width, height) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = imgUrl;
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = width;
                    canvas.height = height;
                    
                    // Draw image scaled down to the machine size
                    ctx.drawImage(img, 0, 0, width, height);
                    const data = ctx.getImageData(0, 0, width, height).data;
                    const newPattern = [];

                    const palette = window.game_object.GameThemes.CubeColors.data;

                    for (let y = 0; y < height; y++) {
                        const row = [];
                        for (let x = 0; x < width; x++) {
                            const i = (y * width + x) * 4;
                            const r = data[i], g = data[i+1], b = data[i+2];
                            
                            // Logic: Find which of our 5 colors is closest to this pixel
                            let closestID = 0;
                            let minDist = Infinity;
                            
                            Object.keys(palette).forEach(id => {
                                const col = new THREE.Color(palette[id].code);
                                const dr = r - col.r * 255;
                                const dg = g - col.g * 255;
                                const db = b - col.b * 255;
                                const dist = dr*dr + dg*dg + db*db; // Math: distance check
                                if(dist < minDist) { minDist = dist; closestID = parseInt(id); }
                            });
                            row.push(closestID);
                        }
                        newPattern.push(row);
                    }
                    resolve(newPattern);
                };
            });
        }
        
        // Replace your old GRID variable
        const GRID = window.game_object.GameProperties.GridSize.count;
        const Chars = [];
        const occupancy = Array.from({length: GRID}, () => Array(GRID).fill(null));
        let tiles = [];
        let tileOccupancy = [];
        let spacingGlobal = 1.2;
        const pickable = [];
        const activeAnims = [];
        const cubesToSmash = [];
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        const clock = new THREE.Clock();
        let baseCharModel = null;
        let globalCharScale = 1.2; // Default, will be updated by loader
        let movingBeltTex = null; // For the animated conveyor belt
        let totalTime = 0; // Game time for idle animations

function createCharLabelTexture(text) {
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    const ctx = canvas.getContext('2d');

    // Matching the game reference style: Bold white with thick black outline
    const fontSize = 150;
    ctx.font = `bold ${fontSize}px Arial Black, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // 1. Draw Thick Black Outline
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 28; 
    ctx.lineJoin = 'round';
    ctx.strokeText(text, 128, 128);

    // 2. Draw White Text Fill
    ctx.fillStyle = '#ffffff';
    ctx.fillText(text, 128, 128);

    return new THREE.CanvasTexture(canvas);
}

function createCharLabel(Char) {
    const text = Char.userData.value.toString();
    const texture = createCharLabelTexture(text);
    const spriteMaterial = new THREE.SpriteMaterial({ 
        map: texture, 
        transparent: true,
        depthTest: false
    });
    const sprite = new THREE.Sprite(spriteMaterial);
    sprite.scale.set(4, 4, 1);
    return sprite;
}

function updateCharLabel(Char) {
    const text = Char.userData.value.toString();
    const texture = createCharLabelTexture(text);
    const label = Char.children.find(child => child.isSprite);
    if (label) {
        label.material.map.dispose();
        label.material.map = texture;
        label.material.needsUpdate = true;
    }
}

        // Char Loader
        loader.load(window.game_object.GameElements.CharModel.data, function(gltf) {
            baseCharModel = gltf.scene; // Save reference for cloning new Chars later
            const base = gltf.scene;

            // Compute scale based on original model size, so every clone uses same scale
            const baseBox = new THREE.Box3().setFromObject(base);
            const baseSize = baseBox.getSize(new THREE.Vector3());
            const maxDim = Math.max(baseSize.x, baseSize.y, baseSize.z);
            const scale = 1.2 / maxDim;
            globalCharScale = scale; // Save this value for spawning

            const grid = GRID;
            const spacing = Math.max(maxDim * scale * 1.6, 1.2);
            spacingGlobal = spacing;
            // Initial grid characters will be spawned after level analysis

            // Create 5 tiles below thread mill, above Char grid (centered horizontally)
            tiles = [];
            const tileCount = 5;
            const tileSize = Math.min(spacing * 0.9, 1.2);
            const tileHeight = 0.06;
            // z position: between thread mill and Char grid with more separation
            const zTiles = 3;
            tileOccupancy = Array(tileCount).fill(null);
            for (let i = 0; i < tileCount; i++) {
                const geom = new THREE.BoxGeometry(tileSize, tileHeight, tileSize);
                const mat = new THREE.MeshStandardMaterial({ color: 0x2b2d46 });
                const tile = new THREE.Mesh(geom, mat);
                tile.receiveShadow = true;
                tile.castShadow = false;
                tile.position.x = (i - Math.floor(tileCount/2)) * spacing;
                tile.position.z = zTiles;
                tile.position.y = tileHeight / 2 + 0.01;
                scene.add(tile);
                tiles.push(tile);
            }

        }, undefined, function(err){
            console.error('Error loading Char.glb', err);
        });

        // Create conveyor belt texture with arrow pattern
function createConveyorBeltTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');

    // Belt base color
    ctx.fillStyle = '#3d4000373';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Chevron '<' arrows using the arrow color
    ctx.strokeStyle = '#4a5080';
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    const stepX = 32;
    const stepY = 32;
    const chevronW = 7;
    const chevronH = 10;

    for (let row = 0; row < canvas.height / stepY + 1; row++) {
        for (let col = 0; col < canvas.width / stepX + 1; col++) {
            const cx = col * stepX + stepX / 2;
            const cy = row * stepY + stepY / 2;

            ctx.beginPath();
            ctx.moveTo(cx + chevronW, cy - chevronH);
            ctx.lineTo(cx - chevronW, cy);
            ctx.lineTo(cx + chevronW, cy + chevronH);
            ctx.stroke();
        }
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(4, 4);
    return texture;
}

        // Load Thread mill FBX at the top/front of the layout
        const fbxLoader = new FBXLoader();
        const MACHINE_MODEL_PATH = "Tread mill.fbx";
        const TRAY_MODEL_PATH = "Tray_@(1).fbx";
        let threadMillModel = null; // Declare this globally with other variables at top
        // Machine Loader
        fbxLoader.load(MACHINE_MODEL_PATH, function(object) {
            threadMillModel = object;
            object.scale.set(.32, .32, 0.32);
            object.position.set(0, 0, -3);
            object.rotation.y = -Math.PI / 2;
            
            // Create our new texture
            movingBeltTex = createConveyorBeltTexture();
            
       object.traverse((node) => {
    if (node.isMesh) {
        node.castShadow = true;
        node.receiveShadow = true;

        const name = node.name.toLowerCase();

        // Belt surface mesh → scrolling chevron texture
        if (name.includes('belt') || name.includes('conveyor')) {
            node.material = new THREE.MeshStandardMaterial({
                map: movingBeltTex,
                metalness: 0.1,
                roughness: 0.85
            });

        // Side/frame/body meshes → flat #b8cbe4 steel-blue
        } else {
            node.material = new THREE.MeshStandardMaterial({
                color: 0x93a7d5,
                metalness: 0.3,
                roughness: 0.6
            });
        }
    }
});
            
            scene.add(object);

            // Load a small tray into the treadmill gap (reference placement)
            fbxLoader.load(TRAY_MODEL_PATH, function(tray) {
                // Scale and place relative to the machine bounding box centre
                tray.scale.set(0.32, 0.32, 0.32);
                const machineBox = new THREE.Box3().setFromObject(object);
                const mCenter = machineBox.getCenter(new THREE.Vector3());
                // Position the tray slightly above the machine center and towards the front gap
                tray.position.set(mCenter.x + 0.21, mCenter.y + 0.2, mCenter.z + 0.2);
                tray.rotation.y = object.rotation.y;
                tray.traverse(node => {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                        // Give a simple material so it reads well in the scene
                        node.material = new THREE.MeshStandardMaterial({ color: 0x7e86a6, metalness: 0.15, roughness: 0.55 });
                    }
                });
                scene.add(tray);
            }, undefined, function(err) { console.error('Error loading Tray_@(1).fbx', err); });
        }, undefined, function(err) {
            console.error('Error loading Thread mill.fbx', err);
        });

  

        // Load Cube_@@.fbx and create grouped cube arrangement
        const cubeLoader = new FBXLoader();
        
        // NEW AUTOMATIC LOADER
        const imgLevelUrl = "Screenshot 2026-02-18 132325.png"; // UPLOAD YOUR IMAGE HERE

        const LEVEL_ROWS = window.game_object.GameProperties.LevelSize.rows;
        const LEVEL_COLS = window.game_object.GameProperties.LevelSize.cols;

        parseImageToLevel(imgLevelUrl, LEVEL_ROWS, LEVEL_COLS).then(autoPattern => {
            // 1. COUNT EVERY CUBE PER COLOR (The Census)
            const colorCensus = {};
            autoPattern.forEach(row => {
                row.forEach(id => {
                    const color = cubeColorsData[id].code;
                    colorCensus[color] = (colorCensus[color] || 0) + 1;
                });
            });

            // Remove background/black from mission colors
            activeLevelColors = Object.keys(colorCensus).filter(c => c !== '#000000');
            console.log('Active Mission Colors (from level pattern):', activeLevelColors, 'Census:', colorCensus);

            // 2. Load Cubes and place them
            cubeLoader.load(window.game_object.GameElements.ObstacleModel.data, (cubeModel) => {
                const rows = autoPattern.length;
                const cols = autoPattern[0].length;
                const cubeSpacing = 0.24;

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const colorCode = autoPattern[r][c];
                        const colorHex = window.game_object.GameThemes.CubeColors.data[colorCode].code;

                        const clone = cubeModel.clone();
                        clone.scale.setScalar(window.game_object.GameProperties.CubeSize.size);
                        clone.position.set((c - cols/2) * cubeSpacing, 0.5, (r - rows/2) * cubeSpacing - 2.5);

                        clone.userData = { colorName: colorHex, gridX: c, gridZ: r, blocked: true };

                        // Color the cube automatically based on image pixel
                        clone.traverse(n => {
                            if (n.isMesh) {
                                n.material = n.material.clone();
                                n.material.color.set(colorHex);
                            }
                        });
                        scene.add(clone);
                        cubesToSmash.push(clone);
                    }
                }
                updateObstacleStatus();

                // 3. DEFINE THE FINITE 9 CHARACTERS WITH MATHEMATICAL AMMO
                const pigPlan = [];
                for (let i = 0; i < GRID * GRID; i++) {
                    // Assign colors from mission colors only
                    pigPlan.push({
                        color: activeLevelColors[i % activeLevelColors.length]
                    });
                }

                // 4. DISTRIBUTE AMMO FAIRLY
                // Math: Ammo per character = (Total Cubes of color X) / (Total Characters of color X) + 2 buffer
                pigPlan.forEach(plan => {
                    const charCountOfThisColor = pigPlan.filter(p => p.color === plan.color).length;
                    const totalCubesNeeded = colorCensus[plan.color];
                    plan.ammo = Math.ceil(totalCubesNeeded / charCountOfThisColor) + 2;
                });

                console.log('Pig Plan (9 characters with calculated ammo):', pigPlan);

                // 5. SPAWN THE 9 FINITE CHARACTERS
                function spawnFiniteGrid() {
                    if (!baseCharModel) {
                        setTimeout(spawnFiniteGrid, 100);
                        return;
                    }
                    let pIdx = 0;
                    for (let r = 0; r < GRID; r++) {
                        for (let c = 0; c < GRID; c++) {
                            const plan = pigPlan[pIdx];
                            createStartingCharacter(r, c, plan.color, plan.ammo);
                            pIdx++;
                        }
                    }
                }
                spawnFiniteGrid();
            });
        });

        // Animation helper: add an animation object with update(dt)
        function addAnim(anim) { activeAnims.push(anim); }

        function tweenPosition(obj, from, to, duration) {
            return new Promise(resolve => {
                const anim = {
                    elapsed: 0,
                    duration,
                    update(dt) {
                        this.elapsed += dt;
                        const t = Math.min(this.elapsed / this.duration, 1);
                        obj.position.lerpVectors(from, to, t);
                        if (t >= 1) { return true; }
                        return false;
                    },
                    finish: resolve
                };
                addAnim(anim);   
            });
        }

        function runCircle(obj, center, duration, rotations = 2, radius = 0.25) {
            return new Promise(resolve => {
                const anim = {
                    elapsed: 0,
                    duration,
                    update(dt) {
                        this.elapsed += dt;
                        const t = Math.min(this.elapsed / this.duration, 1);
                        const angle = t * rotations * Math.PI * 2;
                        obj.position.x = center.x + Math.cos(angle) * radius;
                        obj.position.z = center.z + Math.sin(angle) * radius;
                        obj.rotation.y += dt * 6.0; // spin while running
                        if (t >= 1) { return true; }
                        return false;
                    },
                    finish: resolve
                };
                addAnim(anim);
            });
        }

        function processAnims(dt) {
            for (let i = activeAnims.length - 1; i >= 0; --i) {
                const a = activeAnims[i];
                const done = a.update(dt);
                if (done) {
                    if (a.finish) a.finish();
                    activeAnims.splice(i, 1);
                }
            }
        }

        function updateObstacleStatus() {
            cubesToSmash.forEach(target => {
                const x = target.userData.gridX;
                const z = target.userData.gridZ;

                // Check 4 neighbors
                const hasN = cubesToSmash.some(o => o.userData.gridX === x && o.userData.gridZ === z - 1);
                const hasS = cubesToSmash.some(o => o.userData.gridX === x && o.userData.gridZ === z + 1);
                const hasE = cubesToSmash.some(o => o.userData.gridX === x + 1 && o.userData.gridZ === z);
                const hasW = cubesToSmash.some(o => o.userData.gridX === x - 1 && o.userData.gridZ === z);

                // If surrounded on all 4 sides, it is an "inside" cube and blocked
                target.userData.blocked = (hasN && hasS && hasE && hasW);
            });
        }

// Calculates the snout based on current 3D rotation
function getMouthPosition(pig) {
    const mouthOffset = new THREE.Vector3(0, 0.45, 0.7); 
    mouthOffset.applyQuaternion(pig.quaternion); 
    return pig.position.clone().add(mouthOffset);
}

        // Shake animation for blocked Chars
        function shakeChar(Char) {
            const originalX = Char.position.x;
            const shakeAmount = 0.1;
            const shakeDuration = 200;
            
            addAnim({
                elapsed: 0,
                duration: shakeDuration,
                update(dt) {
                    this.elapsed += dt;
                    const t = this.elapsed / this.duration;
                    const shakes = 4;
                    const shakePhase = Math.sin(t * shakes * Math.PI * 2);
                    Char.position.x = originalX + shakePhase * shakeAmount;
                    if (t >= 1) {
                        Char.position.x = originalX;
                        return true;
                    }
                    return false;
                }
            });
        }

        // Recoil Effect (Squash & Stretch)
        function applyRecoil(Char) {
            const originalScale = globalCharScale;
            addAnim({
                elapsed: 0, duration: 150,
                update(dt) {
                    this.elapsed += dt;
                    const t = this.elapsed / this.duration;
                    // 0 -> 0.5 (squash) -> 1 (reset)
                    const squash = Math.sin(t * Math.PI);
                    Char.scale.z = originalScale * (1 - squash * 0.2); // Shrink length
                    Char.scale.y = originalScale * (1 + squash * 0.1); // Bulge height
                    if (t >= 1) { 
                        Char.scale.setScalar(originalScale);
                        return true; 
                    }
                    return false;
                }
            });
        }

// Visual glowing "Pop" when firing
function createMuzzleFlash(pos) {
    const flashGeom = new THREE.SphereGeometry(0.35, 12, 12);
    const flashMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
    const flash = new THREE.Mesh(flashGeom, flashMat);
    flash.position.copy(pos);
    scene.add(flash);
    addAnim({
        elapsed: 0, duration: 120,
        update(dt) {
            this.elapsed += dt; const t = this.elapsed / this.duration;
            flash.scale.setScalar(1 + t * 2); flash.material.opacity = 1 - t;
            if (t >= 1) { scene.remove(flash); return true; } return false;
        }
    });
}

// CUBE POP AND BLAST ANIMATION: Squeeze -> Expansion -> Shatter
function playCubePopAnimation(cube, cubeColor) {
    const originalScale = window.game_object.GameProperties.CubeSize.size; // 0.03
    const popDuration = 240;

    addAnim({
        elapsed: 0, duration: popDuration,
        update(dt) {
            this.elapsed += dt;
            const t = this.elapsed / this.duration;

            if (t < 0.4) {
                // STAGE 1: THE SQUEEZE (Compressive reaction to bullet impact)
                // 0% -> 40% time: Cube gets thinner on X/Z, stretches tall on Y
                const squeeze = Math.sin((t / 0.4) * Math.PI);
                cube.scale.set(
                    originalScale * (1 - squeeze * 0.4), // Compress width
                    originalScale * (1 + squeeze * 0.6), // Stretch height (The Pop-up)
                    originalScale * (1 - squeeze * 0.4)  // Compress depth
                );
            } else {
                // STAGE 2: THE BLAST (Rapid expansion before shatter)
                // 40% -> 100% time: Expands outward rapidly, fades to transparent
                const blast = (t - 0.4) / 0.6;
                const expand = 1 + Math.sin(blast * Math.PI) * 0.8; // Puffs out
                cube.scale.setScalar(originalScale * expand);
                
                // Fade all materials to invisible
                cube.traverse(n => {
                    if (n.material) {
                        n.material.transparent = true;
                        n.material.opacity = 1 - blast;
                    }
                });
            }

            if (t >= 1) {
                createImpactEffect(cube.position.clone(), cubeColor); // Spawn final shards
                scene.remove(cube);
                return true;
            }
            return false;
        }
    });
}

// 2. Impact Shard Effect (At the Cube)
function createImpactEffect(pos, color) {
    for (let i = 0; i < 4; i++) {
        const shard = new THREE.Mesh(
            new THREE.SphereGeometry(0.08, 4, 4),
            new THREE.MeshBasicMaterial({ color: color })
        );
        shard.position.copy(pos);
        const velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.1,
            Math.random() * 0.1,
            (Math.random() - 0.5) * 0.1
        );
        scene.add(shard);

        addAnim({
            elapsed: 0, duration: 300,
            update(dt) {
                this.elapsed += dt;
                const t = this.elapsed / this.duration;
                shard.position.add(velocity);
                shard.scale.setScalar(1 - t);
                if (t >= 1) { scene.remove(shard); return true; }
                return false;
            }
        });
    }
}

// NEW HIGH-QUALITY AMMO: White Glowing Sphere with a long Trail + Cube Pop Trigger
function createBullet(pig, targetCube, color) {
    const from = getMouthPosition(pig);
    const targetPos = targetCube.position.clone();
    
    // Core of the bullet (Glowing White Ball)
    const bulletGroup = new THREE.Group();
    
    // 1. The Head
    const head = new THREE.Mesh(
        new THREE.SphereGeometry(0.18, 16, 16),
        new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 10, toneMapped: false })
    );
    
    // 2. The Tail (Stretch line)
    const tail = new THREE.Mesh(
        new THREE.CylinderGeometry(0.12, 0.02, 1.2, 12),
        new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 })
    );
    tail.rotation.x = Math.PI / 2; // Lie flat
    tail.position.z = -0.5; // Place behind the head
    
    bulletGroup.add(head);
    bulletGroup.add(tail);
    bulletGroup.position.copy(from);
    scene.add(bulletGroup);

    addAnim({
        elapsed: 0, duration: 180, // High speed flight
        update(dt) {
            this.elapsed += dt;
            const t = Math.min(this.elapsed / this.duration, 1);
            
            // Starts fast, finishes smoothly (Snappy!)
            const easedT = 1 - Math.pow(1 - t, 3);
            bulletGroup.position.lerpVectors(from, targetPos, easedT);
            bulletGroup.lookAt(targetPos); // Points the trail exactly behind the head

            if (t >= 1) { 
                // --- TRIGGER THE CUBE POP AND BLAST UPON BULLET IMPACT ---
                playCubePopAnimation(targetCube, color);
                scene.remove(bulletGroup); 
                return true; 
            }
            return false;
        }
    });
}

// Integrated Combat Loop with Recoil & Beautiful Projectiles
async function shootAtCubes(pig) {
    const myColor = pig.userData.colorName;

    while (pig.userData.moving && pig.userData.value > 0) {
        let target = null;
        let minDist = 7;

        cubesToSmash.forEach((cube, index) => {
            if (cube.userData.colorName === myColor && !cube.userData.blocked) {
                const dist = pig.position.distanceTo(cube.position);
                if (dist < minDist) { minDist = dist; target = { cube, index }; }
            }
        });

        if (target) {
            // PRECISION TIMING: Mark cube as "gone" immediately for other pigs
            const targetRef = target.cube;
            cubesToSmash.splice(target.index, 1);
            
            // Trigger character effects
            applyRecoil(pig);                      // 1. Character Kickback
            createMuzzleFlash(getMouthPosition(pig)); // 2. Snout light pop
            
            // SEND CUBE REFERENCE: The bullet will trigger the pop animation on arrival
            createBullet(pig, targetRef, myColor); // 3. The Glow Bullet + Pop Animation
            
            // Recalculate inner/outer cube status (reveals previously blocked cubes)
            updateObstacleStatus();
            
            pig.userData.value--;
            updateCharLabel(pig);

            // Safety check for empty ammo
            if (pig.userData.value <= 0) {
                const idx = pig.userData.currentTileIndex;
                if (idx !== undefined && tileOccupancy[idx] === pig) tileOccupancy[idx] = null;
                scene.remove(pig);
                pig.userData.moving = false;
                return;
            }
        }
        await new Promise(r => setTimeout(r, 220)); 
    }
}

       // --- Corrected Helper Functions ---
function moveAlongPoint(obj, target, duration) {
    return new Promise(resolve => {
        const start = obj.position.clone();
        addAnim({
            elapsed: 0, duration,
            update(dt) {
                this.elapsed += dt;
                const t = Math.min(this.elapsed / this.duration, 1);
                obj.position.lerpVectors(start, target, t);
                if (t >= 1) return true;
                return false;
            },
            finish: resolve
        });
    });
}

// Function for jumps (parabola)
function jumpToPoint(obj, target, duration) {
    return new Promise(resolve => {
        const start = obj.position.clone();
        const arcHeight = 2.0; // Higher arc for clearance
        addAnim({
            elapsed: 0, duration,
            update(dt) {
                this.elapsed += dt;
                const t = Math.min(this.elapsed / this.duration, 1);
                obj.position.lerpVectors(start, target, t);
                // Simple parabola
                obj.position.y = THREE.MathUtils.lerp(start.y, target.y, t) + Math.sin(t * Math.PI) * arcHeight;
                if (t >= 1) return true;
                return false;
            },
            finish: resolve
        });
    });
}

async function performMillTravel(Char, targetTile) {
    if (!threadMillModel) return;
    Char.userData.moving = true;

    // --- Start shooting thread immediately in parallel ---
    shootAtCubes(Char);

    // The Path Heights
    const h = window.game_object.GameProperties.SpawnHeight; 
    const mX = threadMillModel.position.x;
    const mZ = threadMillModel.position.z; 

    // YOUR EXISTING NODES
    const pEntryStub    = new THREE.Vector3(mX - 2.25, h, mZ + 4.5);
    const pFrontRight   = new THREE.Vector3(mX + 2.8, h, mZ + 4.5);
    const pBackRight    = new THREE.Vector3(mX + 3.4, h, mZ - 2.8);
    const pBackLeft     = new THREE.Vector3(mX - 3.4, h, mZ - 2.8);

    // --- ADDED PHASE 5: THE BLUE ARROW NODE ---
    // Moving from the Back-Left corner down the left rail to the tip
    const pExitTip      = new THREE.Vector3(mX - 3.4, h, mZ + 2.8); 
    
    // THE FINAL JUMP TARGET
    const pFinalTile    = new THREE.Vector3(targetTile.position.x, 0.3, targetTile.position.z);

    // --- PHASE 1: JUMP IN ---
    Char.rotation.y = Math.PI / 2; 
    await jumpToPoint(Char, pEntryStub, 700);
    if (!Char.parent) return; // Char might be destroyed if value hits 0!

    // --- PHASE 2: TRAVEL RIGHT ---
    Char.rotation.y = Math.PI/2; 
    await moveAlongPoint(Char, pFrontRight, 600);
    if (!Char.parent) return;

    // --- PHASE 3: TRAVEL UP RIGHT SIDE ---
    Char.rotation.y = Math.PI; 
    await moveAlongPoint(Char, pBackRight, 600);
    if (!Char.parent) return;

    // --- PHASE 4: TRAVEL LEFT ACROSS TOP ---
    Char.rotation.y = -Math.PI / 2; 
    await moveAlongPoint(Char, pBackLeft, 800);
    if (!Char.parent) return;

    // --- PHASE 5: THE BLUE ARROW (MOVE DOWN LEFT RAIL) ---
    // New step: walk from the back-left corner to the exit tip
    Char.rotation.y = 0; // Turn to look down toward the arrow tip
    await moveAlongPoint(Char, pExitTip, 500);
    if (!Char.parent) return;

    // --- PHASE 6: FINAL JUMP FROM EXIT TO TILE ---
    Char.rotation.y = Math.PI / 2; 
    await jumpToPoint(Char, pFinalTile, 700);
    if (!Char.parent) return;

    Char.userData.onTile = true;
    Char.userData.moving = false;
}
   function onPointerDown(event) {
    const rect = renderer.domElement.getBoundingClientRect();
    pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(pointer, camera);

    const intersects = raycaster.intersectObjects(scene.children, true);
    if (intersects.length === 0) return;

    let obj = intersects[0].object;
    let Char = null;
    while (obj) {
        if (obj.userData && obj.userData.parentChar) {
            Char = obj.userData.parentChar;
            break;
        }
        obj = obj.parent;
    }

    if (!Char || Char.userData.moving) return;

    // --- CHECK CURRENT CAPACITY ---
    const nextAvailableSlot = tileOccupancy.indexOf(null);

    // --- PATH A: CHARACTER IS ON A TILE ---
    if (Char.userData.onTile) {
        if (Char.userData.value > 0) {
            // Instant Undeployment: This character clears its seat immediately
            const currentSlot = Char.userData.currentTileIndex;
            if (currentSlot !== undefined) {
                tileOccupancy[currentSlot] = null; // SLOT IS NOW FREE
            }
            Char.userData.onTile = false; 
        } else {
            return; // Finished its job
        }
    } 
    // --- PATH B: CHARACTER IS IN THE GRID ---
    else {
        // ETHIC 1: THE CAPACITY CHECK
        // If there is no space (no 'null' in tileOccupancy), grid Chars are LOCKED
        if (nextAvailableSlot === -1) {
            console.log("WAIT: The tiles are at capacity!");
            shakeChar(Char); // Feedback wiggle
            return; 
        }

        // ETHIC 2: THE TRAFFIC CHECK
        const row = Char.userData.gridRow;
        const col = Char.userData.gridCol;
        for (let r = row - 1; r >= 0; r--) {
            if (occupancy[r][col] !== null) {
                shakeChar(Char); 
                return; // Blocked by character in front
            }
        }

        // Everything clear: Depart from grid
        occupancy[row][col] = null;
        shiftColumnForward(row, col); 
    }

    // --- SHARED LAUNCH PAD ---
    // Now we find the leftmost spot again (either a truly empty one or the one just vacated)
    const tIdx = tileOccupancy.indexOf(null);
    if (tIdx !== -1) {
        tileOccupancy[tIdx] = Char;
        Char.userData.currentTileIndex = tIdx;
        performMillTravel(Char, tiles[tIdx]);
    }
}

// Spawn a finite starting character with calculated ammo
function createStartingCharacter(row, col, color, ammo) {
    if (!baseCharModel) return;
    const clone = baseCharModel.clone(true);
    clone.scale.setScalar(globalCharScale);

    clone.userData = {
        value: ammo, // <--- MATHEMATICAL AMMO
        colorName: color,
        gridRow: row,
        gridCol: col,
        moving: false,
        onTile: false,
        parentChar: clone
    };

    const label = createCharLabel(clone);
    label.position.set(0, 4, 0);
    label.renderOrder = 999;
    clone.add(label);

    clone.traverse((node) => {
        if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;
            node.material = node.material.clone();
            if (node.material.color) node.material.color.set(color);
            node.userData.parentChar = clone;
        }
    });

    const x = (col - Math.floor(GRID/2)) * spacingGlobal;
    const z = (row - Math.floor(GRID/2)) * spacingGlobal + 7;
    clone.position.set(x, 0.5, z);
    clone.rotation.y = Math.PI / 2;

    scene.add(clone);
    occupancy[row][col] = clone;
    Chars.push(clone);
}

function spawnNewChar(row, col) {
    if (!baseCharModel || activeLevelColors.length === 0) return;

    const newChar = baseCharModel.clone(true);
    newChar.scale.setScalar(globalCharScale);

    // CRITICAL: Pull from MISSION COLORS only
    const missionColor = activeLevelColors[Math.floor(Math.random() * activeLevelColors.length)];
    const val = Math.random() > 0.5 ? 20 : 40;
    newChar.userData = {
        value: val,
        gridRow: row,
        gridCol: col,
        moving: false,
        onTile: false,
        parentChar: newChar,
        colorName: missionColor
    };

    const label = createCharLabel(newChar);
    label.position.set(0, 4, 0);
    label.renderOrder = 999;
    newChar.add(label);

    newChar.traverse((node) => {
        if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;
            node.material = node.material.clone();
            if (node.material.color) node.material.color.set(missionColor);
            node.userData.parentChar = newChar;
        }
    });

    const x = (col - Math.floor(GRID/2)) * spacingGlobal;
    const z = (row - Math.floor(GRID/2)) * spacingGlobal + 7;
    newChar.position.set(x, 0.5, z + 2);
    newChar.rotation.y = Math.PI / 2;

    scene.add(newChar);
    occupancy[row][col] = newChar;

    const landingPos = new THREE.Vector3(x, 0.5, z);
    jumpToPoint(newChar, landingPos, 500);
}

function shiftColumnForward(vacatedRow, col) {
    // Move existing Chars up
    for (let r = vacatedRow + 1; r < GRID; r++) {
        const trailingChar = occupancy[r][col];
        if (trailingChar) {
            const targetRow = r - 1;
            occupancy[targetRow][col] = trailingChar;
            occupancy[r][col] = null;
            trailingChar.userData.gridRow = targetRow;

            const targetZ = (targetRow - Math.floor(GRID/2)) * spacingGlobal + 7;
            const targetX = (col - Math.floor(GRID/2)) * spacingGlobal;
            jumpToPoint(trailingChar, new THREE.Vector3(targetX, 0.5, targetZ), 400);
        }
    }

    // --- DISABLED: NO RESPAWNING ---
    // The game now has exactly 9 finite characters with calculated ammo.
    // No new characters will spawn. The column will show empty space once exhausted.
}



        renderer.domElement.addEventListener('pointerdown', onPointerDown);

        function onWindowResize() {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        window.addEventListener('resize', onWindowResize);
        window.addEventListener('orientationchange', onWindowResize);

        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta() * 1000, 40); // dt in ms, capped
            totalTime += dt * 0.001; // Game time in seconds
            processAnims(dt);

            // --- CHARACTER EXCITEMENT LOGIC ---
            // Target characters in the 3x3 grid
            for (let r = 0; r < GRID; r++) {
                for (let c = 0; c < GRID; c++) {
                    const char = occupancy[r][c];
                    if (char && !char.userData.moving) {
                        // 1. Swing back and forth (X-rotation for sway)
                        // Offset by grid position so they don't move like robots
                        char.rotation.x = Math.sin(totalTime * 8 + r + c) * 0.15;

                        // 2. Small "nervous" breathing hop
                        char.position.y = 0.5 + Math.abs(Math.sin(totalTime * 4 + r + c)) * 0.05;
                    }
                }
            }

            // Target characters sitting on Tiles
            tileOccupancy.forEach((char, idx) => {
                if (char && !char.userData.moving) {
                    // Sway back and forth
                    char.rotation.x = Math.sin(totalTime * 8 + idx) * 0.15;
                    // Sitting breath hop
                    char.position.y = 0.3 + Math.abs(Math.sin(totalTime * 4 + idx)) * 0.05;
                }
            });

            // --- CONTINUOUS TREADMILL MOVEMENT ---
            if (movingBeltTex) {
                // Shift the arrows horizontally based on frame time
                // -0.006 creates a smooth forward motion
                movingBeltTex.offset.x -= 0.005; 
            }

            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>